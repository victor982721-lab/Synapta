# Encabezado del script genérico
[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
param(
    # Acción principal que define qué hacer
    [ValidateSet('Operacion1','Operacion2','Operacion3','Operacion4','Todo')]
    [string]$Action = 'Todo',

    # Parámetros tipo switch (verdadero/falso)
    [switch]$OpcionExtra1,
    [switch]$OpcionExtra2,
    [switch]$OpcionExtra3,
    [switch]$OpcionExtra4,

    # Validación de ruta de archivo de salida
    [ValidateScript({
        if ($_ -and ($_ -notmatch '(?i)\.txt$')) {
            throw 'La ruta de salida debe terminar en .txt'
        }
        $true
    })]
    [string]$RutaReporte
)

# Parámetros adicionales del script genérico

# Ruta donde se guardará el reporte
[string]$RutaReporte,

# Formato de salida permitido
[ValidateSet('txt','json','csv','all')]
[string]$FormatoReporte = 'txt',

# Validación de una ruta de sesión (no puede estar vacía ni apuntar a un archivo existente)
[ValidateScript({
    if ($_ -eq $null) { return $true }
    if ([string]::IsNullOrWhiteSpace($_)) {
        throw 'La ruta de sesión no puede estar vacía.'
    }
    $full = [IO.Path]::GetFullPath($_)
    if (Test-Path -LiteralPath $full -PathType Leaf) {
        throw "La ruta de sesión apunta a un archivo existente: $full"
    }
    $true
})]
[string]$RutaSesion


# Parámetros relacionados con sesión, red y mantenimiento

# Directorio base de sesión
[string]$RutaSesion,

# Umbral mínimo de "salud" (0 a 100)
[ValidateRange(0,100)]
[int]$PuntajeSaludMinimo = 0,

# Lista de hosts en red (no nulos ni vacíos)
[ValidateNotNullOrEmpty()]
[string[]]$HostsRed,

# Puerto de red válido (1 a 65535)
[ValidateRange(1,65535)]
[int]$PuertoRed,

# Espacio libre mínimo requerido (en GB, entre 1 y 100000)
[ValidateRange(1,100000)]
[int]$EspacioLibreMinGB = 2,

# Switches adicionales (banderas opcionales)
[switch]$CrearPuntoRestauracion,
[switch]$HabilitarServicioRemoto,
[switch]$LimpiarTemporales


# Validación de rutas adicionales (ej. carpetas de limpieza extra)
[ValidateScript({
    if ($_ -eq $null) { return $true }
    foreach ($ruta in $_) {
        # Debe ser string válido
        if (-not ($ruta -is [string]) -or [string]::IsNullOrWhiteSpace($ruta)) {
            throw "Ruta inválida en RutasExtra."
        }

        # No puede ser raíz vacía
        $nombre = [IO.Path]::GetFileName($ruta)
        if ([string]::IsNullOrWhiteSpace($nombre)) {
            throw "No se permiten rutas raíz: $ruta"
        }

        # Obtener ruta completa y validar bloqueadas
        $completa = [IO.Path]::GetFullPath($ruta)
        foreach ($bloqueada in @(
            'C:\Sistema',
            'C:\Aplicaciones',
            'C:\DatosCompartidos',
            'C:\Usuarios'
        )) {
            if ($completa.TrimEnd('\') -like ($bloqueada + '*')) {
                throw "Ruta bloqueada por seguridad: $completa"
            }
        }
    }
    $true
})]
[string[]]$RutasExtra


# Parámetros finales del script genérico

# Rutas adicionales (validación ya definida arriba)
[string[]]$RutasExtra,

# Switch para limpieza de componentes genéricos
[switch]$LimpiezaComponentes,

# Ruta de transcripción o bitácora
[string]$RutaTranscripcion,

# Nivel de detalle del log
[ValidateSet('Error','Warn','Info','Debug')]
[string]$NivelLog = 'Info',

# Tiempo de espera por fase (puede ser objeto, int, etc.)
[object]$TiempoEsperaFase,

# Switches adicionales de control
[switch]$CrearRespaldo,
[switch]$IncluirComplementos,
[switch]$IncluirPaquetes = $true,
[switch]$OmitirPaso1,
[switch]$OmitirPaso2,
[switch]$OmitirPaso3,
[switch]$OmitirPaso4,
[switch]$OmitirPaso5,

# Autoevaluación y control de salida
[switch]$AutoPrueba,
[switch]$DefinirCodigoSalida
)