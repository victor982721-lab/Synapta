# Estrategia de prompts y plantillas

## Resumen ejecutivo
Este informe sintetiza 3 conversación(es) sobre **Estrategia de prompts y plantillas**.
Principales intenciones detectadas:
- Lee y analiza detalladamente lo siguiente: ~~~~~ ```powershell # PowerShell 5
- Lee y analiza detalladamente lo siguiente: ~~~~~ Aquí tienes un método breve y efectivo para comprobar coherencia entre **Instrucciones del proyecto** y **archivos de referencia**: 1
- Lee y analiza por completo lo siguiente: ~~~~~ # Project_Instructions --- ## Contexto 1

## Alcance y supuestos
- Basado exclusivamente en el contenido presente en las conversaciones fuente.
- Se excluyen saludos, disculpas y texto genérico sin valor técnico.
- Se preservan fragmentos técnicos, prompts y código tal como aparecen (con mínimos ajustes de formato).

## Procedimiento paso a paso
⚠️ FALTA: No se detectaron pasos numerados explícitos en las fuentes de este grupo.

## Mejores prompts / plantillas
- ⚠️ FALTA: No se hallaron prompts/plantillas explícitos en las fuentes.

## Ejemplos completos
**Caso de 5-50-50-_SOP___Env_Survey_ — <SOP - Env Survey>**

*Entrada (user):*

> Lee y analiza detalladamente lo siguiente: ~~~~~ ```powershell # PowerShell 5.1–7.x — Env Survey (pégalo y corre) Set-StrictMode -Version Latest $ErrorActionPreference = 'Stop' # -------------------- CONFIG Editable -------------------- $Config = [pscustomobject]@{ OutDir = $null # Ej: 'C:\Users\Me\Desktop\TBEA\_out\env' | null = auto IncludeModules = $false # true para listar módulos (puede tardar) MaxModules = 100 # límite de módulos JsonDepth = 10 # profundidad para ConvertTo-Json NoMarkdown = $false # true para no generar .md } # --------------------------------------------------------- function New-AtomicUtf8File { param( [Parameter(Mandatory)][string]$Path, [Parameter(Mandatory)][string]$Content, [switch]$Utf8NoBOM ) $dir = Split-Path -Parent $Path if (-not (Test-Path -LiteralPath $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } $tmp = "$Path.tmp" $bak = "$Path.bak" $enc = if ($Utf8NoBOM) { New-Object System.Text.UTF8Encoding($false) } else { New-Object System.Text.UTF8Encoding($true) } [System.IO.File]::WriteAllText($tmp, $Content, $enc) if (Test-Path -LiteralPath $Path) { Copy-Item -LiteralPath $Path -Destination $bak -Force } Move-Item -LiteralPath $tmp -Destination $Path -Force } function Get-EnvSurvey { param( [switch]$IncludeModules, [int]$MaxModules = 100 ) $errors = New-Object System.Collections.Generic.List[string] # Intentar registrar CodePages (PS7 / .NET Core); inocuo si no existe try { [System.Text.Encoding]::RegisterProvider([System.Text.CodePagesEncodingProvider]::Instance) } catch {} # Admin $isAdmin = $false try { $id = [Security.Principal.WindowsIdentity]::GetCurrent() $pr = New-Object Security.Principal.WindowsPrincipal($id) $isAdmin = $pr.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator) } catch { $errors.Add("AdminCheck: $($_.Exception.Message)") } # PS / Host $psTable = $PSVersionTable $hostInfo = [ordered]@{ HostName = $Host.Name HostVersion = "$($Host.Version)" PSHome = $PSHOME PSExecutable = (Get-Process -Id $PID | Select-Object -ExpandProperty Path) ProfilePath = $PROFILE ProfileExists = (Test-Path -LiteralPath $PROFILE) } # Cultura / TZ try { $culture = Get-Culture } catch { $errors.Add("Culture: $($_.Exception.Message)"); $culture=$null } try { $uiCulture = Get-UICulture } catch { $errors.Add("UICulture: $($_.Exception.Message)"); $uiCulture=$null } try { $tz = Get-TimeZone } catch { $errors.Add("TimeZone: $($_.Exception.Message)"); $tz=$null } # Codificaciones $encInfo = [ordered]@{ ConsoleInput = $null ConsoleOutput = $null PS_OutputEncoding = $null DotNet_Default = $null Default_CodePage = $null CP936_Available = $false } try { $encInfo.ConsoleInput = [Console]::InputEncoding.WebName } catch {} try { $encInfo.ConsoleOutput = [Console]::OutputEncoding.WebName } catch {} try { $encInfo.PS_OutputEncoding = $OutputEncoding.WebName } catch {} try { $encInfo.DotNet_Default = [Text.Encoding]::Default.WebName; $encInfo.Default_CodePage = [Text.Encoding]::Default.CodePage } catch {} try { [Text.Encoding]::GetEncoding(936) | Out-Null; $encInfo.CP936_Available = $true } catch {} # Execution Policy $execPolicies = $null try { $execPolicies = Get-ExecutionPolicy -List | Select-Object Scope,ExecutionPolicy } catch { $errors.Add("ExecutionPolicy: $($_.Exception.Message)") } # PATH $envPaths = @() try { $envPaths = $env:PATH -split ';' | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique } catch { $errors.Add("PATH: $($_.Exception.Message)") } # Terminal/env $terminal = [ordered]@{ WindowsTerminal = [bool]$env:WT_SESSION TERM = $env:TERM ConEmu = [bool]$env:ConEmuBuild VSCode = [bool]$env:VSCODE_GIT_IPC_HANDLE } # Proxy $proxies = [ordered]@{ HTTP_PROXY = $env:HTTP_PROXY HTTPS_PROXY = $env:HTTPS_PROXY NO_PROXY = $env:NO_PROXY WinHTTP = $null } try { $wh = (& netsh winhttp show proxy) 2>$null if ($wh) { $proxies.WinHTTP = ($wh -join "`n") } } catch { $errors.Add("netsh.winhttp: $($_.Exception.Message)") } # dotnet / git $dotnetInfo = $null try { $dotnetInfo = (& dotnet --info) -join "`n" } catch { $errors.Add("dotnet: $($_.Exception.Message)") } $gitInfo = $null try { $gitInfo = (& git --version) } catch { $errors.Add("git: $($_.Exception.Message)") } # Sistema (Get-ComputerInfo con fallback CIM) $comp = $null try { if (Get-Command Get-ComputerInfo -ErrorAction SilentlyContinue) { $comp = Get-ComputerInfo -Property OsName,OsVersion,OsBuildNumber,OsArchitecture,WindowsInstallDateFromRegistry, CsManufacturer,CsModel,CsSystemType,CsNumberOfLogicalProcessors,CsTotalPhysicalMemory,CsDomain,CsIsVirtualMachine } else { throw "Get-ComputerInfo not available" } } catch { $errors.Add("Get-ComputerInfo: $($_.Exception.Message)") try { $os = Get-CimInstance Win32_OperatingSystem $cs = Get-CimInstance Win32_ComputerSystem $comp = [pscustomobject]@{ OsName = $os.Caption OsVersion = $os.Version OsBuildNumber = $os.BuildNumber OsArchitecture = $os.OSArchitecture WindowsInstallDateFromRegistry = $os.InstallDate CsManufacturer = $cs.Manufacturer CsModel = $cs.Model CsSystemType = $cs.SystemType CsNumberOfLogicalProcessors = $cs.NumberOfLogicalProcessors CsTotalPhysicalMemory = $cs.TotalPhysicalMemory CsDomain = $cs.Domain CsIsVirtualMachine = [bool]($cs.Model -match 'Virtual|VMware|Hyper-V') } } catch { $errors.Add("CIM fallback: $($_.Exception.Message)") } } # Discos $disks = @() try { $disks = Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3" | Select-Object ` @{n='Drive';e={$_.DeviceID}}, FileSystem, @{n='SizeGB';e={[math]::Round(($_.Size/1GB),2)}}, @{n='FreeGB';e={[math]::Round(($_.FreeSpace/1GB),2)}}, @{n='UsedGB';e={[math]::Round((($_.Size-$_.FreeSpace)/1GB),2)}} } catch { $errors.Add("Disks: $($_.Exception.Message)") } # Red $net = @() try { if (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) { $net = Get-NetIPConfiguration | ForEach-Object { [pscustomobject]@{ InterfaceAlias = $_.InterfaceAlias IPv4 = ($_.IPv4Address.IPAddress -join ',') IPv6 = ($_.IPv6Address.IPAddress -join ',') DNS = ($_.DnsServer.ServerAddresses -join ',') Gateway = ($_.IPv4DefaultGateway.NextHop) } } } else { $net = Get-CimInstance Win32_NetworkAdapterConfiguration -Filter "IPEnabled=TRUE" | ForEach-Object { [pscustomobject]@{ InterfaceAlias = $_.Description IPv4 = ($_.IPAddress | Where-Object { $_ -match '^\d+\.' } -join ',') IPv6 = ($_.IPAddress | Where-Object { $_ -match ':' } -join ',') DNS = ($_.DNSServerSearchOrder -join ',') Gateway = ($_.DefaultIPGateway -join ',') } } } } catch { $errors.Add("Network: $($_.Exception.Message)") } # Módulos (opcional, rápido) $modules = @() if ($IncludeModules) { try { $modules = Get-Module -ListAvailable | Sort-Object Name,Version | Select-Object -First $MaxModules Name,Version,Path,ModuleType, @{n='ExportedCommandsCount';e={ if ($_.ExportedCommands) { ($_.ExportedCommands.Keys).Count } else { 0 } }} } catch { $errors.Add("Modules: $($_.Exception.Message)") } } # Vars núcleo $envVarsCore = @( 'USERNAME','USERDOMAIN','COMPUTERNAME','PROCESSOR_ARCHITECTURE', 'NUMBER_OF_PROCESSORS','OS','SystemRoot','ComSpec', 'TEMP','TMP','ProgramFiles','ProgramFiles(x86)','ChocolateyInstall' ) | ForEach-Object { [pscustomobject]@{ Name=$_; Value= (Get-Item -Path "Env:$_" -ErrorAction SilentlyContinue).Value } } $report = [ordered]@{ generated_at_local = (Get-Date).ToString("yyyy-MM-ddTHH:mm:sszzz") is_admin = $isAdmin ps_version_table = $psTable host = $hostInfo culture = if ($culture) {[ordered]@{ CultureName = $culture.Name UICultureName = if ($uiCulture) { $uiCulture.Name } else { $null } ANSI_CodePage = $culture.TextInfo.ANSICodePage OEM_CodePage = $culture.TextInfo.OEMCodePage }} else { $null } timezone = if ($tz) {[ordered]@{ Id=$tz.Id; BaseUtcOffset=$tz.BaseUtcOffset.ToString() }} else { $null } encodings = $encInfo execution_policy = $execPolicies terminal = $terminal proxies = $proxies env_paths = $envPaths env_core_vars = $envVarsCore computer = $comp disks = $disks network = $net dotnet_info = $dotnetInfo git_version = $gitInfo ps_module_path = ($env:PSModulePath -split ';') modules_sample = $modules errors = $errors } return $report } # Resolver OutDir por defecto (Windows 10/11) if (-not $Config.OutDir) { $desktop = [Environment]::GetFolderPath('Desktop') $tbea = Join-Path $desktop 'TBEA' if (Test-Path -LiteralPath $tbea) { $Config.OutDir = Join-Path $tbea '_out\env' } else { $Config.OutDir = Join-Path (Get-Location) '_out\env' } } # Ejecutar levantamiento $report = Get-EnvSurvey -IncludeModules:([bool]$Config.IncludeModules) -MaxModules $Config.MaxModules # Salidas $jsonPath = Join-Path $Config.OutDir 'env-survey.json' $jsonSummary = Join-Path $Config.OutDir 'env-survey-summary.json' $mdPath = Join-Path $Config.OutDir 'env-survey.md' # JSON completo (UTF-8 con BOM; Notepad-friendly) $jsonFull = $report | ConvertTo-Json -Depth $Config.JsonDepth New-AtomicUtf8File -Path $jsonPath -Content $jsonFull # Resumen ligero $summary = [ordered]@{ generated_at_local = $report.generated_at_local is_admin = $report.is_admin ps_version = $report.ps_version_table.PSVersion host = $report.host timezone = $report.timezone encodings = $report.encodings execution_policy = $report.execution_policy disks = $report.disks network = $report.network dotnet_info_head = if ($report.dotnet_info) { ($report.dotnet_info -split "`n" | Select-Object -First 15) -join "`n" } else { $null } git_version = $report.git_version modules_count = @($report.modules_sample).Count errors = $report.errors } New-AtomicUtf8File -Path $jsonSummary -Content ($summary | ConvertTo-Json -Depth 6) # Markdown opcional if (-not $Config.NoMarkdown) { $md = @" # Env Survey (Windows PowerShell 5.1 / PowerShell 7) Generado: $($report.generated_at_local) ## Sistema - Admin: $($report.is_admin) - OS: $($report.computer.OsName) $($report.computer.OsVersion) (Build $($report.computer.OsBuildNumber)) [$($report.computer.OsArchitecture)] - Equipo: $($report.computer.CsManufacturer) $($report.computer.CsModel) — Cores: $($report.computer.CsNumberOfLogicalProcessors) — RAM: $( if ($report.computer.CsTotalPhysicalMemory) { [math]::Round($report.computer.CsTotalPhysicalMemory/1GB,2) } else { 'n/a' } ) GB - VM: $($report.computer.CsIsVirtualMachine) ## PowerShell / Host - $($report.host.HostName) $($report.host.HostVersion) - PSHome: $($report.host.PSHome) - Ejecutable: $($report.host.PSExecutable) - Profile: $($report.host.ProfilePath) (Exists=$($report.host.ProfileExists)) ## Localización / Zona - Culture: $($report.culture.CultureName) — UI: $($report.culture.UICultureName) - TimeZone: $($report.timezone.Id) (UTC offset $($report.timezone.BaseUtcOffset)) ## Consola / Codificaciones - In: $($report.encodings.ConsoleInput) - Out: $($report.encodings.ConsoleOutput) - PS \$OutputEncoding: $($report.encodings.PS_OutputEncoding) - .NET Default: $($report.encodings.DotNet_Default) (CP=$($report.encodings.Default_CodePage)) - CP936 disponible: $($report.encodings.CP936_Available) ## Seguridad - ExecutionPolicy: $( ($report.execution_policy | ForEach-Object { " - {0}: {1}" -f $_.Scope, $_.ExecutionPolicy }) -join "`n" ) ## Red / Proxy - HTTP(S)_PROXY: $($report.proxies.HTTP_PROXY), $($report.proxies.HTTPS_PROXY) - NO_PROXY: $($report.proxies.NO_PROXY) - WinHTTP: ``` $($report.proxies.WinHTTP) ``` ## PATH (top 15) $( (($report.env_paths | Select-Object -First 15) | ForEach-Object { " - $_" }) -join "`n" ) ## Discos $( ($report.disks | ForEach-Object { " - {0} {1} Size={2}GB Free={3}GB Used={4}GB" -f $_.Drive, $_.FileSystem, $_.SizeGB, $_.FreeGB, $_.UsedGB }) -join "`n" ) ## .NET / Git - dotnet --info (resumen): ``` $([string]::Join("`n", ($report.dotnet_info -split "`n" | Select-Object -First 20))) ``` - git: $($report.git_version) ## PSModulePath $( ($report.ps_module_path | ForEach-Object { " - $_" }) -join "`n" ) ## Módulos (muestra) $( ($report.modules_sample | ForEach-Object { " - {0} {1} ({2}) cmds={3}" -f $_.Name, $_.Version, $_.Path, $_.ExportedCommandsCount }) -join "`n" ) ## Errores capturados $( if ($report.errors.Count -gt 0) { ($report.errors | ForEach-Object { " - $_" }) -join "`n" } else { " - (ninguno)" } ) "@ New-AtomicUtf8File -Path $mdPath -Content $md } Write-Host ("Saved JSON: {0}" -f $jsonPath) Write-Host ("Saved SUMMARY: {0}" -f $jsonSummary) if (-not $Config.NoMarkdown) { Write-Host ("Saved Markdown: {0}" -f $mdPath) } Write-Host "Done." ``` ¡Va muy bien! Tienes **propósito claro, metas medibles y foco en trazabilidad**. Para que funcione “en cancha”, te sugiero estos ajustes concretos (pegables al SOP) que cierran brechas operativas y facilitan auditoría: ### 1) Definiciones y alcance (añadir al “Contexto”) * **Sesión:** intervalo desde crear/mover un chat al proyecto hasta su cierre formal. * **Checkpoint:** combinación inmutable de `prompt_version`, `fileset_version`, `model`, `settings` (seed/temperature), y fecha. * **Cierre de sesión:** cuando se generan artefactos y se registra en bitácora (ver §6). ### 2) Roles y RACI (nuevo) * **Owner (O):** mantiene el Prompt Maestro y aprueba cambios. * **Operador (Op):** ejecuta sesiones y completa bitácoras. * **Auditor (Au):** verifica coherencia instrucciones↔archivos y KPIs. * RACI por actividad: Arranque (O/Op - R, Au - C), Auditoría (Au - R, O - A), Cambios (O - R/A, Au - C). ### 3) Flujo de arranque “TTI ≤ 3 min” (nuevo, paso a paso) 1. **Crear/mover chat** al proyecto correcto. 2. **Aplicar Checkpoint**: `prompt_version` + `fileset_version` + `model`. 3. **Cargar set base (CSV)** y abrir “bitácora sesión” (plantilla). 4. **Prueba sanitaria** (1 input corto + expected). 5. **Ejecutar tarea**. 6. **Sellar sesión**: exportar artefactos y registrar métricas. ### 4) KPIs: cómo medir (operativiza tus metas) | KPI | Fórmula | Fuente | Cadencia | Umbral | | ---------------- | ---------------------------------------------- | ------------------------------- | ----------- | ------ | | Consistencia | σ(outputs base) / μ ≤ **15%** | CSV base + script de evaluación | Cada sesión | ≤15% | | Reproducibilidad | (# casos iguales / # casos deterministas) ×100 | Re-runs con mismo checkpoint | Semanal | ≥95% | | TTI | t(listo) − t(nueva sesión) | Bitácora | Cada sesión | ≤3 min | | Gobernanza | campos_ok / campos_obl ×100 | Auditoría integral | Cada sesión | ≥98% | | Seguridad | incidentes_PII | Registro de incidentes | Mensual | =0 | | Mejora continua | ΔPrompt por 10 sesiones | Changelog | Mensual | ≥1 | ### 5) Coherencia instrucciones ↔ archivos (resume la práctica) * **Matriz** Instrucción→Evidencia (archivo/sección, fecha, estado OK/CONFLICTO/FALTA). * **Precedencia** declarada: `Spec_vX > Manual_vY > Notas`. * **Regla:** si hay contradicción, el Operador detiene producción y solicita fix al Owner. ### 6) Artefactos obligatorios por sesión (para tu trazabilidad end-to-end) * **CSV inicial** (set base y expected/heurísticos). * **Bitácora** (una fila por sesión): `session_id, date, model, prompt_version, fileset_version, TTI, variance_base, reproducibility, governance_score, incidents, notes` * **Changelog del Prompt Maestro** (semántico): `feat/fix/docs + impacto`. ### 7) Sección “Auditoría” (micro-plantilla accionable) * **Objetivo:** verificar alineación con capacidades actuales del modelo y coherencia instrucciones↔archivos. * **Entrada:** tabla de cambios post-cutoff (la que ya tienes). * **Salida:** Matriz de verificación + recomendaciones priorizadas (H/M/B) y due dates. ### 8) Seguridad y cumplimiento (checklist corto) * PII/credenciales: **nunca** en archivos ni instrucciones. * Etiquetado de datos sensibles en CSV (`pii=false`). * Revisión de riesgos antes de cerrar sesión (2 min). ### 9) “Prompt Maestro” — encabezado mínimo (pegable) ```md # PROMPT MAESTRO — SOP01 vX.Y.Z ## Contexto del proyecto [objetivo, público, restricciones] ## Reglas de estilo y formato [tono, estructura de salida, citación, campos obligatorios] ## Uso de archivos del proyecto - Prioriza: Spec_vX > Manual_vY > Notas - Si no hay evidencia, pregunta; no inventes. ## Política de seguridad - No proceses PII/secretos; reporta si detectas. ## Procedimiento [pasos de resolución, validaciones, golden tests] ``` ### 10) Encaje con tu “Objetivo Particular” (redacción sugerida) > **Auditar con evidencia reciente el proyecto AutoScript_AR y verificar:** (1) cumplimiento de SOP01 al inicio de cada sesión; (2) alineación con capacidades vigentes del modelo (post-cutoff); (3) coherencia entre instrucciones y archivos. Emitir informe con matriz de verificación, impacto y plan de acción. Si quieres, te lo convierto en un **SOP completo** con estas secciones integradas y una **plantilla de bitácora/CSV** lista para usar. ~~~~~

*Salida (assistant):*

> ¡Gracias! Leí todo con lupa: el script **Env Survey (PowerShell 5.1–7.x)** y las sugerencias SOP que incluiste al final. Aquí tienes un **análisis práctico y accionable**. # Qué hace el script (resumen rápido) - **Levanta un inventario del entorno**: versión de PowerShell/host, cultura/TZ, codificaciones, ExecutionPolicy, PATH, variables núcleo, SO/hardware, discos, red, proxies (WinHTTP), `dotnet --info`, `git --version`, `PSModulePath` y (opcional) muestra de módulos. - **Devuelve artefactos**: - `env-survey.json` (completo, UTF-8 con BOM) - `env-survey-summary.json` (resumen) - `env-survey.md` (informe legible) - **Escritura atómica**: helper `New-AtomicUtf8File` (tmp + bak) y autocrea directorio. # Lo bueno (sólido) - **Propósito claro y “pegable”** (pasta-y-corre). - **Cobertura amplia** con *fallbacks* (CIM si no hay `Get-ComputerInfo`; WMI si no hay `Get-NetIPConfiguration`). - **Robustez**: captura de errores en lista, tolerancia a ausencia de `dotnet/git`. - **Configurabilidad**: `IncludeModules`, `MaxModules`, `JsonDepth`, `OutDir`, `NoMarkdown`. - **Informes útiles** (JSON full + resumen + MD). # Hallazgos y riesgos (priorizados) **Crítico** 1) **StrictMode + `null` en e...

---

**Caso de 5-58-16-_Trazabilidad_y_coherencia_ — <Trazabilidad y coherencia>**

*Entrada (user):*

> Lee y analiza detalladamente lo siguiente: ~~~~~ Aquí tienes un método breve y efectivo para comprobar coherencia entre **Instrucciones del proyecto** y **archivos de referencia**: 1. **Inventario y descomposición** * Lista los archivos (título, fecha, versión) y **divide las instrucciones en “cláusulas atómicas”** (una regla o criterio por línea, con ID). 2. **Matriz de trazabilidad (instrucción → evidencia)** * Para cada cláusula, identifica **dónde vive la evidencia** (archivo, sección/página) y su **vigencia** (fecha/versión). * Usa esta tabla y marca estado: | ID | Instrucción (resumida) | Evidencia (archivo + sección) | Vigencia | Estado | Nota/Fix | | ---- | ---------------------- | ------------------------------ | ---------- | --------- | ---------------------------------- | | I-01 | “Usar tono formal” | `Guía_Estilo v3.pdf §2` | 2025-07-10 | OK | — | | I-02 | “Umbral = 0.75” | `Spec_Modelo.xlsx hoja Config` | 2024-11-02 | CONFLICTO | En `README.md` dice 0.70; unificar | 3. **Criterios de coherencia (úsalos como checklist)** * **Consistencia:** no hay contradicciones entre instrucciones y archivos (números, definiciones, pasos). * **Completitud:** toda instrucción tiene evidencia; si falta, crear/actualizar el archivo fuente. * **Vigencia (recency):** la instrucción referencia **versiones/fechas actuales**; evita citar documentos obsoletos. * **Precedencia:** define jerarquía (p. ej., “Spec_v3 > Manual_v2 > Notas”). * **Aplicabilidad:** el modelo puede ejecutar la instrucción con lo que hay en archivos (sin ambigüedad). 4. **Pruebas de comportamiento (golden tests)** * Diseña 5–10 **tareas representativas** (inputs reales). * Evalúa si la salida **cumple cada cláusula** (tono, fuentes, límites, pasos). * Si falla: ajusta **instrucciones** (más claras/prioridades) o **archivos** (corrige dato/versión). 5. **Automatización ligera dentro del Proyecto (útil para iterar)** Pega este prompt en un chat del Proyecto con los archivos cargados: ``` Actúa como verificador de coherencia. 1) Extrae una lista numerada de cláusulas atómicas de las Instrucciones del proyecto. 2) Para cada cláusula, busca evidencia en los archivos del proyecto (cita archivo y sección/página). 3) Produce la matriz: ID | Instrucción | Evidencia | Vigencia | Estado (OK/CONFLICTO/FALTA) | Nota/Fix. 4) Señala contradicciones y sugiere la fuente canónica (según precedencia). 5) Propón 3 pruebas breves para validar tras los cambios. ``` *(Opcional)* Añade en las Instrucciones: **“Si hay conflicto, prioriza `Spec_Producto vX` por fecha más reciente; nunca uses documentos sin fecha.”* 6. **Cierre y mantenimiento** * Ejecuta fixes (unificar números, actualizar versiones, eliminar duplicados). * **Sella la coherencia**: actualiza las Instrucciones con “fuentes canónicas” y **fechas ISO**. * Repite el check **tras cada cambio de archivo clave** o en cadencia semanal. ~~~~~

*Salida (assistant):*

> ¡Buen método! Está bien enfocado en trazabilidad y “pruebas de aceptación” rápidas. Aquí tienes un análisis crítico y varias mejoras para operativizarlo sin fricción (plantillas + mini-protocolo + script auxiliar). # Diagnóstico (qué tan sólido está el enfoque) - **Fortalezas** - **Trazabilidad explícita** (instrucción → evidencia) y atención a **vigencia/precedencia**. - Introduce **golden tests** para validar el comportamiento real, no solo la documentación. - Es **agnóstico de dominio** y aplicable a cualquier set de archivos. - **Riesgos / huecos habituales** 1) **Estados insuficientes:** solo OK/CONFLICTO/FALTA; falta “OBSOLETA” (evidencia desactualizada) y “AMBIGUA” (texto interpretable de ≥2 formas). 2) **Vigencia no cuantificada:** conviene una regla concreta (p. ej., “obsoleto si >180 días sin cambio o versión menor que la referida en Instrucciones”). 3) **Precedencia poco operacional:** define tabla de jerarquía con pesos (“Spec > SOP > README > Notas”) y desempate por fecha ISO del documento. 4) **Extracción de versión/fecha:** PDFs/Excels o archivos sin fecha en nombre requieren heurísticas (regex sobre nombre y cabeceras). 5) **Cierre sin SLA:** falta priorización y du...

---

**Caso de 6-26-32-An_lisis_de_instrucciones_proyecto — Análisis de instrucciones proyecto**

*Entrada (user):*

> Lee y analiza por completo lo siguiente: ~~~~~ # Project_Instructions --- ## Contexto 1. ROL ⟶ Eres un **Ingeniero DevOps** con enfoque en administración de proyectos y control documental. 2. Tono ⟶ Directo y conciso, escribe en español técnico, sin redundancias ni adornos. 3. Evitar ⟶ Explicaciones innecesarias: solo responde lo que el usuario solicita. --- ## Misión Generación y edición de documentos y scripts ejecutables en PowerShell 7, aplicando efectiva y consistentemente los protocolos correspondientes para cada caso. --- ## Políticas Las siguientes políticas definen los **principios obligatorios** que guían la generación de entregables dentro del proyecto, definen el marco mínimo de calidad y consistencia que ChatGPT debe aplicar en todos los turnos. - ### **POLÍTICA DE ARTEFACTOS OPERACIONALES** Se denomina *Artefacto* a todo bloque de código **NO PROCESADO CON PYTHON** que en su interior contenga un script o un documento embebido en un script con herestrings, además su contenido debe cumplir con los siguientes atributos: 1. Accionables ⟶ Listos para ejecución directa en consola, sin pasos adicionales. 2. Definitivos ⟶ Solo un artefacto por turno, sin opciones adicionales ni variables por definir. 3. Blindados ⟶ Con un buen renderizado del bloque de código principal abriendo y cerrando el artefacto con **cinco tildes (`~~~~~`)** a fin de evitar afectaciones de renderizado por bloques anidados. 4. Automatizados ⟶ La gestión de parámetros (rutas, dependencias, creación de directorios) debe estar integrada en el script. La generación y edición de documentos deberá realizarse mediante **herestrings direccionados** a las rutas especificadas en la sección de rutas locales. 5. Validados ⟶ Todo artefacto será verificado mediante simulación con **PSSA** y **Pester**, siguiendo el flujo de validación establecido. 6. Seguros ⟶ Cualquier modificación deberá generar previamente una copia de seguridad `.bak` en la misma carpeta. 7. Modularizados ⟶ Los artefactos deberán redactarse de forma **modular interna** (secciones intercambiables), permitiendo actualizaciones mediante **herestrings y parches**. 8. Compatibles ⟶ Se debe de cuidar la compatibilidad entre Windows 10 y 11, así como PowerShell 5 y 7, pero sin preocuparse por la portabilidad "nix/macOS" 9. Trazables ⟶ Los cambios deben quedar documentados con metadatos de versión, fecha y descripción del cambio por medio de registros añadidos con parches en `/mnt/data/Repo_AR/CHANGELOG.md`, cada registro debe estar separado por una regla horizontal y no debe eliminar ni modificar nada de los registros existentes, solo añadir nuevos registros. La explicación detallada de criterios y procedimientos se encuentra en los protocolos referenciados y disponibles en la ruta: `/mnt/data/Repo_AR/Protocolos/` --- **Rutas de documentos y archivos visibles en entorno local (`C:\Users\VictorFabianVeraVill\Desktop\Repo_AR`):** - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\Project_Instructions.md` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\BACKUPS\` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SCRIPTS\Invoke-RepoReorg.ps1` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SCRIPTS\BACKUPS\Invoke-RepoReorg_20250926_201928305.bak` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SOP\SOP_Auditoria_Proyecto.md` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SOP\SOP_CB_Blindado.md` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SOP\SOP_Context_Update.md` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SOP\SOP_Herestrings.md` - `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SOP\BACKUPS\` --- **Referencias SOP:** - `SOP_Auditoria_Proyecto.md` ⟶ Lineamientos para auditoría del proyecto. - `SOP_CB_Blindado.md` ⟶ Procedimientos de blindaje y control documental. - `SOP_Context_Update.md` ⟶ Instrucciones para actualización de contexto. - `SOP_Herestrings.md` ⟶ Normativa sobre el uso de herestrings en scripts y documentos. --- - ### **POLÍTICA DE ESFUERZO EQUITATIVO** En toda interacción colaborativa entre ChatGPT y el usuario, las responsabilidades deben distribuirse de manera proporcional a las capacidades de cada parte. 1. Capacidades comparativas - *ChatGPT-5* ⟶ Hasta 300× más memoria de trabajo y hasta 1 000× mayor velocidad en ingestión/producción de texto frente a un humano promedio, en tareas de corto y mediano plazo (lectura, razonamiento, escritura, programación). - *Usuario* ⟶ Ventaja en contexto, criterio y memoria de largo plazo. 2. Distribución de responsabilidades - *ChatGPT-5* ⟶ Automatización, generación, análisis y validación (incluyendo simulación PSSA + Pester). - *Usuario* ⟶ Toma de decisiones, aporte de contexto. ~~~~~

*Salida (assistant):*

> Aquí tienes el análisis solicitado —directo y técnico— del bloque **Project_Instructions**. # Resumen ejecutivo El documento fija un **rol DevOps**, una **misión** centrada en generación/edición de documentos y scripts **PowerShell 7** y una **política de artefactos** estricta (blindaje de bloques, modularidad, backups, validación PSSA/Pester, trazabilidad en CHANGELOG). La **política de esfuerzo** asigna a ChatGPT la parte automatizable (generación, análisis, validación) y al usuario las decisiones de negocio/contexto. El marco es coherente y accionable, con algunos puntos a precisar (ver hallazgos). # Requisitos atómicos (trazabilidad) **Contexto** - C1. Rol: Ingeniero DevOps con foco en PM/control documental. - C2. Tono: directo, español técnico, sin adornos. - C3. Evitar explicaciones innecesarias. **Misión** - M1. Generar/editar documentos y scripts *ejecutables* en **PowerShell 7** aplicando protocolos. **Política de artefactos** - A1. Definición de artefacto: bloque de código **no procesado con Python** con script o documento via *herestrings*. - A2. Accionables: ejecutables sin pasos extra. - A3. Definitivos: **un artefacto por turno**; sin variantes ni placeholders. - A4. ...

## Snippets de código / comandos
⚠️ FALTA: No se hallaron snippets de código/comandos.

## Checklists
- ⚠️ FALTA: No se detectaron checklists explícitas.

## Errores comunes y cómo evitarlos
- ⚠️ FALTA: No se documentaron errores comunes en las fuentes.

## Métricas o criterios de calidad
- ⚠️ FALTA: No se identificaron métricas/criterios de calidad explícitos.

## Apéndice: notas y decisiones de fusión
- Canonical: **5-50-50-_SOP___Env_Survey_** ← 5-50-50-_SOP___Env_Survey_(len=53401). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **5-58-16-_Trazabilidad_y_coherencia_** ← 5-58-16-_Trazabilidad_y_coherencia_(len=28342). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-26-32-An_lisis_de_instrucciones_proyecto** ← 6-26-32-An_lisis_de_instrucciones_proyecto(len=30225). Nota: Agrupación por similitud Jaccard de shingles (k=5).

## Mapa de trazabilidad (este informe)

| archivo_original | formato | título/tema detectado | rol(es) relevantes | porción aprovechada (sí/no) | observaciones de deduplicación |
|---|---|---|---|---|---|
| 2025-9-29/5-50-50-_SOP___Env_Survey_.md | md | <SOP - Env Survey> | assistant, system, user | sí |  |
| 2025-9-29/5-50-50-_SOP___Env_Survey_.json | json | <SOP - Env Survey> | assistant, system, user | sí |  |
| 2025-9-29/5-58-16-_Trazabilidad_y_coherencia_.md | md | <Trazabilidad y coherencia> | assistant, system, user | sí |  |
| 2025-9-29/5-58-16-_Trazabilidad_y_coherencia_.json | json | <Trazabilidad y coherencia> | assistant, system, user | sí |  |
| 2025-9-29/6-26-32-An_lisis_de_instrucciones_proyecto.md | md | Análisis de instrucciones proyecto | assistant, system, user | sí |  |
| 2025-9-29/6-26-32-An_lisis_de_instrucciones_proyecto.json | json | Análisis de instrucciones proyecto | assistant, system, user | sí |  |