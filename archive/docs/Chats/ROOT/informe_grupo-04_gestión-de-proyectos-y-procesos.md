# Gestión de proyectos y procesos

## Resumen ejecutivo
Este informe sintetiza 10 conversación(es) sobre **Gestión de proyectos y procesos**.
Principales intenciones detectadas:
- 1
- Analiza y explica que hace el siguiente script: ``` # --- Helper: resuelve una entrada (absoluta o relativa) asegurando que quede BAJO $root --- function Resolve-UnderRoot { param( [Parameter(Mandator
- Analiza y explica que entiendes con lo siguiente: ``` Contexto de workspace - root = C:\Users\VictorFabianVeraVill\mnt - Abreviaturas: "docs/chatgpt" = <root>\docs\chatgpt - Nuevo proyecto "X": crear

## Alcance y supuestos
- Basado exclusivamente en el contenido presente en las conversaciones fuente.
- Se excluyen saludos, disculpas y texto genérico sin valor técnico.
- Se preservan fragmentos técnicos, prompts y código tal como aparecen (con mínimos ajustes de formato).

## Procedimiento paso a paso
⚠️ FALTA: No se detectaron pasos numerados explícitos en las fuentes de este grupo.

## Mejores prompts / plantillas
- ⚠️ FALTA: No se hallaron prompts/plantillas explícitos en las fuentes.

## Ejemplos completos
**Caso de 4-58-47-_WsW_mnt_ — <WsW_mnt>**

*Entrada (user):*

> 1. Revisa de forma recursiva el interior de este .zip 2. Lee los documentos al interior. 3. Explica la estructura observada. 4. Explica el contenido de los archivos.

*Salida (assistant):*

> {'content_type': 'code', 'language': 'unknown', 'response_format_name': None, 'text': 'import os, zipfile, json, sys, textwrap, pathlib, hashlib, mimetypes, re, io, csv, base64, binascii, datetime\r\n\r\nzip_path = "/mnt/data/mnt.zip"\r\nres = {}\r\nif not os.path.exists(zip_path):\r\n res[\'exists\'] = False\r\n res[\'message\'] = "Zip not found"\r\n res\r\nelse:\r\n res[\'exists\'] = True\r\n # Open zip and collect info\r\n z = zipfile.ZipFile(zip_path, \'r\')\r\n file_infos = []\r\n for zi in z.infolist():\r\n # Skip directory entries\r\n is_dir = zi.is_dir() if hasattr(zi, \'is_dir\') else zi.filename.endswith(\'/\')\r\n size = zi.file_size\r\n compress_size = zi.compress_size\r\n date_time = datetime.datetime(*zi.date_time).isoformat()\r\n path = zi.filename\r\n ext = pathlib.Path(path).suffix.lower()\r\n # Try read small files to detect type\r\n content_summary = None\r\n text_head = None\r\n bytes_head = None\r\n detected_type = None\r\n if not is_dir:\r\n with z.open(zi, \'r\') as f:\r\n head = f.read(4096)\r\n # Detect if text\r\n try:\r\n text_head = head.decode(\'utf-8\')\r\n detected_type = \'text\'\r\n except UnicodeDecodeError:\r\n try:\r\n text_head = head.decode(\'l...

---

**Caso de 5-16-29-_WsW_Script_ — <WsW_Script>**

*Entrada (user):*

> Analiza y explica que hace el siguiente script: ``` # --- Helper: resuelve una entrada (absoluta o relativa) asegurando que quede BAJO $root --- function Resolve-UnderRoot { param( [Parameter(Mandatory)][string]$Root, [Parameter(Mandatory)][string]$Input ) $s = $Input.Trim() # ¿ruta absoluta con unidad? (C:\..., D:\...) if ($s -match '^[A-Za-z]:\\') { $p = $s } else { # permitir que el usuario ponga "\data\..." o "data\..." if ($s.StartsWith('\')) { $s = $s.Substring(1) } $p = Join-Path $Root $s } # normalizar y validar que esté dentro de $Root $full = [System.IO.Path]::GetFullPath($p) $rootFull = [System.IO.Path]::GetFullPath($Root + [System.IO.Path]::DirectorySeparatorChar) if (-not $full.StartsWith($rootFull, [System.StringComparison]::OrdinalIgnoreCase)) { throw "La ruta '$full' queda fuera del root '$Root'." } return $full } # --- MENÚ (reemplaza tu Start-WorkspaceWizard) --- function Start-WorkspaceWizard { $defaultRoot = Join-Path $HOME 'mnt' $root = Read-Host "Root del workspace (ENTER para '$defaultRoot')" if ([string]::IsNullOrWhiteSpace($root)) { $root = $defaultRoot } # Aquí pides SOLO la subruta (o una absoluta si quieres) $defaultSub = 'data\proyectos\mi-proyecto' $sub = Read-Host "Subruta bajo root (ENTER=$defaultSub). También acepto '\data\...' o ruta absoluta" if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $defaultSub } try { $project = Resolve-UnderRoot -Root $root -Input $sub Write-Host "→ Usando ruta del proyecto: $project" -ForegroundColor Cyan } catch { Write-Host "❌ $($_.Exception.Message)" -ForegroundColor Red return } if (-not (Test-Path $project)) { $create = Read-Host "La ruta no existe. ¿Crear? (y/N)" if ($create -match '^(y|s|si|sí)$') { New-Item -ItemType Directory -Force -Path $project | Out-Null } else { Write-Host "Operación cancelada." -ForegroundColor Yellow return } } $global = Initialize-GlobalTemplates -Root $root Write-Host "`n=== Menú ===" -ForegroundColor Cyan Write-Host "[1] / [A] Instalar plantillas (no sobrescribir)" -ForegroundColor Gray Write-Host "[2] / [B] Instalar + sobrescribir + validar (ShowPlan)" -ForegroundColor Gray Write-Host "[3] / [C] Instalar con skeleton personalizado + validar" -ForegroundColor Gray $choice = Read-Host "Elige opción (1/2/3 o A/B/C)" switch -regex ($choice.ToUpper()) { '^(1|A)$' { $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } '^(2|B)$' { $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map -Overwrite Write-Host "`n— Validando árbol (dry-run, ShowPlan) —" -ForegroundColor Cyan try { $json = Get-Content -LiteralPath $res.ProjMap -Raw | ConvertFrom-Json if ($json.tree) { Test-TreePlan -Base $json.root -Map $json.tree -MaxNodes 200 -MaxDepth 32 -MaxPath 240 -ShowPlan } else { Write-Host "⚠️ filemap.json no contiene 'tree' para validar." -ForegroundColor Yellow } } catch { Write-Host "❌ Error al validar: $($_.Exception.Message)" -ForegroundColor Red } Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } '^(3|C)$' { $sk = Read-Host "Skeleton (lista separada por comas, ej: docs,src,config,results,tests)" $skeleton = @() if (-not [string]::IsNullOrWhiteSpace($sk)) { $skeleton = $sk.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' } } $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map -Overwrite -Skeleton $skeleton Write-Host "`n— Validando árbol (dry-run, ShowPlan) —" -ForegroundColor Cyan try { $json = Get-Content -LiteralPath $res.ProjMap -Raw | ConvertFrom-Json if ($json.tree) { Test-TreePlan -Base $json.root -Map $json.tree -MaxNodes 200 -MaxDepth 32 -MaxPath 240 -ShowPlan } else { Write-Host "⚠️ filemap.json no contiene 'tree' para validar." -ForegroundColor Yellow } } catch { Write-Host "❌ Error al validar: $($_.Exception.Message)" -ForegroundColor Red } Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } default { Write-Host "Opción no válida. Cancelo." -ForegroundColor Yellow } } } # =============================================== # Workspace Wizard (interactivo) — PS 5/7 # - Menú 1/2/3 o A/B/C # - Instala plantillas .workspace/, ajusta filemap.root # - Validación opcional (dry-run) sin crear árbol real # =============================================== # ---------- Helpers ---------- function Ensure-Directory($p) { if ($p) { New-Item -ItemType Directory -Force -Path $p | Out-Null } } function Write-File($p, $content) { $dir = Split-Path -Parent $p; Ensure-Directory $dir; Set-Content -LiteralPath $p -Value $content -Encoding utf8 } function Get-MapKeys($m) { if ($m -is [hashtable]) { return @($m.Keys) } elseif ($m -is [pscustomobject]) { return @($m.PSObject.Properties.Name) } else { return @() } } function Get-MapChild($m, $name) { if ($m -is [hashtable]) { return $m[$name] } elseif ($m -is [pscustomobject]) { return $m.$name } else { return $null } } # ---------- Validador DRY-RUN ---------- function Test-TreePlan { [CmdletBinding()] param( [Parameter(Mandatory)][string]$Base, [Parameter(Mandatory)]$Map, # hashtable o PSCustomObject [int]$MaxDepth = 32, [int]$MaxNodes = 1000, [int]$MaxPath = 240, [switch]$ShowPlan ) $errors = New-Object System.Collections.Generic.List[string] $planned = 0 $visited = [System.Collections.Generic.HashSet[object]]::new() $invalidChars = [regex]'[<>:"/\\|?*]' $reserved = @('CON','PRN','AUX','NUL','COM1','COM2','COM3','COM4','COM5','COM6','COM7','COM8','COM9','LPT1','LPT2','LPT3','LPT4','LPT5','LPT6','LPT7','LPT8','LPT9') function Check-Name([string]$name, [string]$parentPath) { if ($name -match $invalidChars) { return "Nombre inválido '$name' en '$parentPath' (caracteres no permitidos)." } if ($reserved -contains $name.ToUpper()) { return "Nombre reservado de Windows: '$name' en '$parentPath'." } if ($name.TrimEnd() -ne $name -or $name.EndsWith('.')) { return "Nombre no permitido (espacio/punto al final): '$name' en '$parentPath'." } if ($name.Length -gt 255) { return "Componente demasiado largo (>255): '$name' en '$parentPath'." } return $null } $Visit = { param($curBase, $curMap, $depth) if ($depth -gt $MaxDepth) { $errors.Add("Profundidad excedida ($MaxDepth) en '$curBase'.") Write-Host "❌ Profundidad excedida ($MaxDepth) en '$curBase'." -ForegroundColor Red return } if ($visited.Contains($curMap)) { return } [void]$visited.Add($curMap) $names = @(Get-MapKeys $curMap) $dups = $names | Group-Object { $_.ToUpper() } | Where-Object { $_.Count -gt 1 } foreach ($g in $dups) { $errors.Add("Duplicados (case-insensitive) en '$curBase': " + ($g.Group -join ', ')) Write-Host "❌ Duplicados (case-insensitive) en '$curBase': $($g.Group -join ', ')" -ForegroundColor Red } foreach ($name in $names) { $nameErr = Check-Name -name $name -parentPath $curBase if ($nameErr) { $errors.Add($nameErr); Write-Host "❌ $nameErr" -ForegroundColor Red; continue } $path = Join-Path $curBase $name if ($path.Length -gt $MaxPath) { $errors.Add("Ruta demasiado larga ($($path.Length)>$MaxPath): $path") Write-Host "❌ Ruta demasiado larga ($($path.Length)>$MaxPath): $path" -ForegroundColor Red continue } $planned++ if ($planned -gt $MaxNodes) { $errors.Add("Se superó MaxNodes ($MaxNodes).") Write-Host "❌ Se superó MaxNodes ($MaxNodes)." -ForegroundColor Red return } if ($ShowPlan) { Write-Host "CREATE: $path" -ForegroundColor Cyan } $child = Get-MapChild $curMap $name if ($child -is [hashtable] -or $child -is [pscustomobject]) { & $Visit $path $child ($depth + 1) } elseif ($null -ne $child) { $errors.Add("Valor no soportado en '$path' (se esperaba hashtable/objeto, no: $($child.GetType().Name)).") Write-Host "❌ Valor no soportado en '$path'." -ForegroundColor Red } } } & $Visit $Base $Map 0 $ok = ($errors.Count -eq 0) $summary = [pscustomobject]@{ Base = $Base PlannedNodes = $planned MaxNodes = $MaxNodes MaxDepth = $MaxDepth MaxPath = $MaxPath ErrorsCount = $errors.Count Errors = $errors } if ($ok) { Write-Host "✅ Verificación OK. Nodos planificados: $planned" -ForegroundColor Green } else { Write-Host "⚠️ Verificación con errores. Nodos planificados: $planned — Errores: $($errors.Count)" -ForegroundColor Yellow $errors | ForEach-Object { Write-Host "• $_" -ForegroundColor Yellow } } return $summary } # ---------- Inicializar plantillas globales si faltan ---------- function Initialize-GlobalTemplates { param( [Parameter(Mandatory)][string]$Root, [string]$GlobalInstrPath = (Join-Path $Root 'config\plantillas\workspace\instructions.md'), [string]$GlobalMapPath = (Join-Path $Root 'config\filemaps\standard.json') ) if ((Test-Path $GlobalInstrPath) -and (Test-Path $GlobalMapPath)) { return @{Instr=$GlobalInstrPath; Map=$GlobalMapPath} } $GlobalInstrDir = Split-Path -Parent $GlobalInstrPath $GlobalMapDir = Split-Path -Parent $GlobalMapPath Ensure-Directory $GlobalInstrDir Ensure-Directory $GlobalMapDir $Instructions = @" Contexto de workspace - root = $Root - Abreviaturas: "docs/chatgpt" = <root>\docs\chatgpt - Nuevo proyecto "X": crear en <root>\data\proyectos\X con subcarpetas {docs, src, config, results} - No escribes en disco: solo dame comandos/archivos listos para copiar/pegar Preferencias de salida - Sistema: Windows 10/11, PowerShell 7 preferido (acepto PS5 si aplica) - Formato: SOLO bloques de código con los comandos, sin prosa - Encoding: UTF-8 - Evita rutas relativas fuera de <root> Límites de seguridad (duros) - Máx. profundidad: 8 niveles - Máx. nodos a crear por operación: 200 - No proponer cambios fuera de <root> - Validar nombres Windows (sin <>:"/\|?*, sin punto/espacio final; sin nombres reservados) Convenciones - Nombres proyecto: kebab-case (ej. proyecto-ejemplo) - Fechas en archivos: YYYY-MM-DD - Logs en <root>\logs cuando aplique Plantilla por defecto (si no digo lo contrario) - Para “nuevo proyecto X”: crear {docs/, src/, config/, results/} y README.md con título y fecha "@ $FilemapJson = @" { "schema": "filemap@1", "root": "$($Root.Replace('\','\\'))", "tree": { "data": { "proyectos": {}, "datasets": {} }, "docs": { "manuales": {}, "notas": {}, "chatgpt": {} }, "config": { "sistemas": {}, "proyectos": {}, "plantillas": {} }, "archive": { "proyectos": {}, "docs": {} }, "tmp": {} }, "defaults": { "projectSkeleton": ["docs", "src", "config", "results"] } } "@ Write-File $GlobalInstrPath $Instructions Write-File $GlobalMapPath $FilemapJson Write-Host "✔ Plantillas globales inicializadas." -ForegroundColor Green return @{Instr=$GlobalInstrPath; Map=$GlobalMapPath} } # ---------- Instalar en proyecto ---------- function Install-Workspace { param( [Parameter(Mandatory)][string]$ProjectPath, [Parameter(Mandatory)][string]$Root, [string]$GlobalInstrPath, [string]$GlobalMapPath, [switch]$Overwrite, [string[]]$Skeleton ) $ProjectPath = (Resolve-Path -LiteralPath $ProjectPath).Path $WorkspaceDir = Join-Path $ProjectPath '.workspace' Ensure-Directory $WorkspaceDir $ProjInstrPath = Join-Path $WorkspaceDir 'instructions.md' $ProjMapPath = Join-Path $WorkspaceDir 'filemap.json' if ((-not (Test-Path $ProjInstrPath)) -or $Overwrite) { Copy-Item -LiteralPath $GlobalInstrPath -Destination $ProjInstrPath -Force Write-Host "✔ Copiado: $ProjInstrPath" -ForegroundColor Green } else { Write-Host "↷ Saltado (existe): $ProjInstrPath (usa -Overwrite para reemplazar)" -ForegroundColor Yellow } if ((-not (Test-Path $ProjMapPath)) -or $Overwrite) { Copy-Item -LiteralPath $GlobalMapPath -Destination $ProjMapPath -Force Write-Host "✔ Copiado: $ProjMapPath" -ForegroundColor Green } else { Write-Host "↷ Saltado (existe): $ProjMapPath (usa -Overwrite para reemplazar)" -ForegroundColor Yellow } # Ajustar JSON local (root y skeleton) $json = Get-Content -LiteralPath $ProjMapPath -Raw | ConvertFrom-Json if (-not $json.PSObject.Properties.Match('root')) { $json | Add-Member -NotePropertyName root -NotePropertyValue $Root } if (-not $json.PSObject.Properties.Match('defaults')) { $json | Add-Member -NotePropertyName defaults -NotePropertyValue ([ordered]@{}) } if (-not $json.defaults.PSObject.Properties.Match('projectSkeleton')) { $json.defaults | Add-Member -NotePropertyName projectSkeleton -NotePropertyValue @() } $json.root = $Root if ($Skeleton) { $json.defaults.projectSkeleton = $Skeleton } ($json | ConvertTo-Json -Depth 64) | Set-Content -LiteralPath $ProjMapPath -Encoding utf8 Write-Host "✔ Actualizado JSON local: root = $Root" -ForegroundColor Green if ($Skeleton) { Write-Host "✔ defaults.projectSkeleton = $($Skeleton -join ', ')" -ForegroundColor Green } # .gitignore $GitIgnore = Join-Path $ProjectPath '.gitignore' if (-not (Test-Path $GitIgnore)) { New-Item -ItemType File -Path $GitIgnore | Out-Null } if (-not (Select-String -Path $GitIgnore -Pattern '^\s*\.workspace/\s*$' -Quiet)) { Add-Content -Path $GitIgnore -Value ".workspace/" Write-Host "✔ .gitignore actualizado: .workspace/" -ForegroundColor Green } else { Write-Host "↷ .gitignore ya contiene .workspace/" -ForegroundColor Yellow } return @{ WorkspaceDir=$WorkspaceDir; ProjMap=$ProjMapPath } } # ---------- Menú interactivo ---------- function Start-WorkspaceWizard { # Entradas básicas $defaultRoot = Join-Path $HOME 'mnt' $root = Read-Host "Root del workspace (ENTER para '$defaultRoot')" if ([string]::IsNullOrWhiteSpace($root)) { $root = $defaultRoot } $project = Read-Host "Ruta del proyecto (ej. $root\data\proyectos\mi-proyecto)" if (-not (Test-Path $project)) { $create = Read-Host "La ruta no existe. ¿Crear? (y/N)" if ($create -match '^(y|s|si|sí)$') { Ensure-Directory $project } else { Write-Host "Operación cancelada." -ForegroundColor Yellow return } } $global = Initialize-GlobalTemplates -Root $root Write-Host "`n=== Menú ===" -ForegroundColor Cyan Write-Host "[1] / [A] Instalar plantillas (no sobrescribir)" -ForegroundColor Gray Write-Host "[2] / [B] Instalar + sobrescribir + validar (ShowPlan)" -ForegroundColor Gray Write-Host "[3] / [C] Instalar con skeleton personalizado + validar" -ForegroundColor Gray $choice = Read-Host "Elige opción (1/2/3 o A/B/C)" switch -regex ($choice.ToUpper()) { '^(1|A)$' { $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } '^(2|B)$' { $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map -Overwrite Write-Host "`n— Validando árbol (dry-run, ShowPlan) —" -ForegroundColor Cyan try { $json = Get-Content -LiteralPath $res.ProjMap -Raw | ConvertFrom-Json if ($json.tree) { Test-TreePlan -Base $json.root -Map $json.tree -MaxNodes 200 -MaxDepth 32 -MaxPath 240 -ShowPlan } else { Write-Host "⚠️ filemap.json no contiene 'tree' para validar." -ForegroundColor Yellow } } catch { Write-Host "❌ Error al validar: $($_.Exception.Message)" -ForegroundColor Red } Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } '^(3|C)$' { $sk = Read-Host "Skeleton (lista separada por comas, ej: docs,src,config,results,tests)" $skeleton = @() if (-not [string]::IsNullOrWhiteSpace($sk)) { $skeleton = $sk.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' } } $res = Install-Workspace -ProjectPath $project -Root $root -GlobalInstrPath $global.Instr -GlobalMapPath $global.Map -Overwrite -Skeleton $skeleton Write-Host "`n— Validando árbol (dry-run, ShowPlan) —" -ForegroundColor Cyan try { $json = Get-Content -LiteralPath $res.ProjMap -Raw | ConvertFrom-Json if ($json.tree) { Test-TreePlan -Base $json.root -Map $json.tree -MaxNodes 200 -MaxDepth 32 -MaxPath 240 -ShowPlan } else { Write-Host "⚠️ filemap.json no contiene 'tree' para validar." -ForegroundColor Yellow } } catch { Write-Host "❌ Error al validar: $($_.Exception.Message)" -ForegroundColor Red } Write-Host "`n✅ Listo. .workspace en: $($res.WorkspaceDir)" -ForegroundColor Green } default { Write-Host "Opción no válida. Cancelo." -ForegroundColor Yellow } } } # ---------- Lanzar asistente ---------- Start-WorkspaceWizard ```

*Salida (assistant):*

> Aquí va un desglose claro de lo que hace el script (PowerShell) y algunos detalles importantes a notar. # Qué es y para qué sirve Es un **“Workspace Wizard” interactivo** para proyectos en Windows. Su meta es: - Crear (o inicializar) una carpeta de proyecto. - Generar una carpeta **`.workspace/`** dentro del proyecto con dos archivos: - `instructions.md` (guía de trabajo) - `filemap.json` (mapa de árbol planeado) - **Opcionalmente validar en “dry-run”** (sin crear nada) el árbol descrito en `filemap.json`. - Mantener **`.workspace/` en .gitignore**. # Flujo general (lo que verás al ejecutarlo) 1) Te pide un **root** (por defecto: `$HOME\mnt`). 2) Te pide la **ruta del proyecto** (o subruta bajo el root, según la versión de asistente que quede activa; ver “ojo” abajo). 3) Si no existe, te pregunta si la crea. 4) Inicializa plantillas globales bajo `<root>\config\...` si faltan. 5) Muestra un menú: - **[1]/[A]** Instalar plantillas **sin sobrescribir**. - **[2]/[B]** Instalar **sobrescribiendo** + **validar** (dry-run, “ShowPlan”). - **[3]/[C]** Igual que (2) pero además permite **definir un “skeleton”** (p. ej. `docs,src,config,results`) que se guarda en `filemap.json` (no crea dire...

---

**Caso de 5-22-31-_WsW_Contexto_ — <WsW_Contexto>**

*Entrada (user):*

> Analiza y explica que entiendes con lo siguiente: ``` Contexto de workspace - root = C:\Users\VictorFabianVeraVill\mnt - Abreviaturas: "docs/chatgpt" = <root>\docs\chatgpt - Nuevo proyecto "X": crear en <root>\data\proyectos\X con subcarpetas {docs, src, config, results} - No escribes en disco: solo dame comandos/archivos listos para copiar/pegar Preferencias de salida - Sistema: Windows 10/11, PowerShell 7 preferido (acepto PS5 si aplica) - Formato: SOLO bloques de código con los comandos, sin prosa - Encoding: UTF-8 - Evita rutas relativas fuera de <root> Límites de seguridad (duros) - Máx. profundidad: 8 niveles - Máx. nodos a crear por operación: 200 - No proponer cambios fuera de <root> - Validar nombres Windows (sin <>:"/\|?*, sin punto/espacio final; sin nombres reservados) Convenciones - Nombres proyecto: kebab-case (ej. proyecto-ejemplo) - Fechas en archivos: YYYY-MM-DD (ej. 2025-09-28) - Logs en <root>\logs cuando aplique Plantilla por defecto (si no digo lo contrario) - Para “nuevo proyecto X”: crear {docs/, src/, config/, results/} y README.md con título y fecha ```

*Salida (assistant):*

> Esto define un “contrato de trabajo” para cómo debo operar en tu PC (Windows) dentro de un workspace controlado. # Lo esencial que entiendo - **Ámbito**: Todo vive bajo `C:\Users\VictorFabianVeraVill\mnt` (**<root>**). Puedo usar la abreviatura `"docs/chatgpt"` para referirme a `<root>\docs\chatgpt`. No debo proponer ni tocar nada fuera de `<root>`. - **Creación de proyectos**: Un proyecto “X” se crea en `<root>\data\proyectos\X` con subcarpetas `{docs, src, config, results}`. Los nombres de proyecto van en **kebab-case**. - **Salida/entregables**: No debo escribir en disco; te doy **comandos o archivos listos para copiar/pegar**. Prefieres **PowerShell 7** (vale PS5 si aplica). La salida debe ser **solo bloques de código con comandos**, sin prosa, en **UTF-8**. Evitaré rutas relativas que salgan de `<root>`. - **Límites duros**: - Profundidad máxima de estructura: **8 niveles**. - Máximo de **200 nodos** (archivos+carpetas) por operación. - Validación de nombres Windows: sin `<>:"/\|?*`, sin punto/espacio al final, y sin nombres reservados (p.ej. `CON`, `PRN`, `AUX`, `NUL`, `COM1–9`, `LPT1–9`). - **Convenciones**: - Fechas en archivos: `YYYY-MM-DD` (ej. `2025-09-28`). - **Logs** v...

---

**Caso de 5-36-5-_SOP_01___An_lisis__01_ — <SOP_01 - Análisis #01>**

*Entrada (user):*

> Parsea por completo lo siguiente y dame un análisis de lo siguiente: ~~~~~ # Auditoría de Configuración de Proyecto — **Protocolo General** **Objetivo.** Evaluar si un proyecto de ChatGPT aprovecha correctamente Custom Instructions, Project Instructions, archivos y (si aplica) Memoria — independientemente del dominio. ## Entradas requeridas - Texto actual en **Project Instructions** y en **Custom Instructions** (los 3 campos). - Capturas/confirmaciones de estado de **Memoria** (OFF o project‑only). - Listado de **archivos** del proyecto y su propósito. ## Salidas esperadas - **Puntaje** (0–100) por dimensiones. - **Hallazgos** priorizados (Crítico/Alto/Medio/Bajo). - **Acciones correctivas** concretas (una línea cada una). ## Dimensiones y pesos 1) **Claridad y enfoque** (20): objetivos definidos, tono consistente, cero ambigüedad. 2) **Proactividad y contrato de entrega** (20): “un turno, valor”, sin promesas, verificación propia. 3) **Trazabilidad** (15): citas a fuentes **[Oficial]** para capacidades, foros como **[Comunidad/Prensa]**. 4) **Arquitectura de contexto** (15): jerarquía correcta (Proyecto > CI > Prompt), sin depender de memoria. 5) **Operativa de archivos** (10): nombres ASCII, empaquetado, instrucciones de uso. 6) **Actualización y UI** (10): comprobaciones de estado (Proyecto/Memoria), límites de campos medidos. 7) **Calidad de entregables** (10): ejemplos reproducibles, validaciones internas. ## Procedimiento 1) **Inventario**: extrae texto de CI (3 campos) y Project Instructions; lista archivos y tamaños. 2) **Límites**: verifica que cada campo respete su presupuesto (CI ~1500 c/u; Proyecto ~8000 aprox.). 3) **Consistencia**: detecta contradicciones entre CI vs Proyecto; Proyecto debe prevalecer. 4) **Proactividad**: busca frases de “prometer más tarde” o preguntas innecesarias; deben estar prohibidas. 5) **Citas**: comprueba presencia de citas **[Oficial]** cuando se hable de capacidades o planes. 6) **Entregables**: verifica que se pidan nombres ASCII, `.zip` cuando aplique y guía de validación. 7) **Reporte**: emite puntaje por dimensión + lista de acciones (máx. 10 ítems). ## Plantilla de reporte (ejemplo) **Resumen (score total: 84/100)** - Críticos: 0 | Altos: 1 | Medios: 3 | Bajos: 2 **Hallazgos → Acción (una línea):** - Alto — Proyecto excede 8000 char: Reducir y mover detalle a archivos. - Medio — CI carece de “un turno, valor”: Añadir contrato de entrega. - Bajo — Falta política de `.zip`: Incluir en sección de entregables. ## Prompt operativo (copia y pega) > Audita este proyecto con el protocolo general. Reporta puntuación por dimensión, hallazgos priorizados y acciones de una línea. Verifica límites (1500/8000 aprox.), consistencia Proyecto↔CI, y políticas de entregables. No hagas preguntas; entrega el informe en un turno. ~~~~~

*Salida (assistant):*

> # Análisis y “parseo” completo del protocolo ## 1) Qué es y para qué sirve (lectura rápida) El texto define un **protocolo de auditoría** para evaluar proyectos de ChatGPT (independiente del dominio) respecto a cómo usan **Project Instructions**, **Custom Instructions** (CI), **Memoria**, y **archivos**. Estandariza **entradas**, **salidas**, **dimensiones con pesos (100%)**, un **procedimiento** paso a paso, una **plantilla de reporte** y un **prompt operativo** para ejecutar la auditoría en un solo turno. --- ## 2) Parseo estructural (desglose fiel del contenido) ### Entradas requeridas - Texto actual en **Project Instructions** y en **Custom Instructions** (3 campos). - Estado de **Memoria** (OFF o project-only). - **Listado de archivos** del proyecto con su propósito. ### Salidas esperadas - **Puntajes 0–100 por dimensión**. - **Hallazgos priorizados** (Crítico/Alto/Medio/Bajo). - **Acciones correctivas** concretas (una línea c/u). ### Dimensiones y pesos (suman 100) 1. **Claridad y enfoque** — 20 2. **Proactividad y contrato de entrega** — 20 3. **Trazabilidad** — 15 4. **Arquitectura de contexto** — 15 5. **Operativa de archivos** — 10 6. **Actualización y UI** — 10 7. **Cali...

## Snippets de código / comandos
⚠️ FALTA: No se hallaron snippets de código/comandos.

## Checklists
- ⚠️ FALTA: No se detectaron checklists explícitas.

## Errores comunes y cómo evitarlos
- ⚠️ FALTA: No se documentaron errores comunes en las fuentes.

## Métricas o criterios de calidad
- ⚠️ FALTA: No se identificaron métricas/criterios de calidad explícitos.

## Apéndice: notas y decisiones de fusión
- Canonical: **4-58-47-_WsW_mnt_** ← 4-58-47-_WsW_mnt_(len=35476). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **5-16-29-_WsW_Script_** ← 5-16-29-_WsW_Script_(len=47213). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **5-22-31-_WsW_Contexto_** ← 5-22-31-_WsW_Contexto_(len=10144). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **5-36-5-_SOP_01___An_lisis__01_** ← 5-36-5-_SOP_01___An_lisis__01_(len=39758). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **5-52-44-_SOP_01___An_lisis__03_** ← 5-52-44-_SOP_01___An_lisis__03_(len=45025). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-11-18-An_lisis_de_documentaci_n_PS** ← 6-11-18-An_lisis_de_documentaci_n_PS(len=24241). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-31-26-Auditor_a_de_configuraci_n** ← 6-31-26-Auditor_a_de_configuraci_n(len=19966). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-34-30-An_lisis_protocolo_auditor_a** ← 6-34-30-An_lisis_protocolo_auditor_a(len=21157). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-36-14-An_lisis_y_auditor_a_t_cnica** ← 6-36-14-An_lisis_y_auditor_a_t_cnica(len=116596). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-50-15-An_lisis_de_protocolo_SOP01** ← 6-50-15-An_lisis_de_protocolo_SOP01(len=48786). Nota: Agrupación por similitud Jaccard de shingles (k=5).

## Mapa de trazabilidad (este informe)

| archivo_original | formato | título/tema detectado | rol(es) relevantes | porción aprovechada (sí/no) | observaciones de deduplicación |
|---|---|---|---|---|---|
| 2025-9-29/4-58-47-_WsW_mnt_.md | md | <WsW_mnt> | assistant, system, tool, user | sí |  |
| 2025-9-29/4-58-47-_WsW_mnt_.json | json | <WsW_mnt> | assistant, system, tool, user | sí |  |
| 2025-9-29/5-16-29-_WsW_Script_.md | md | <WsW_Script> | assistant, system, user | sí |  |
| 2025-9-29/5-16-29-_WsW_Script_.json | json | <WsW_Script> | assistant, system, user | sí |  |
| 2025-9-29/5-22-31-_WsW_Contexto_.md | md | <WsW_Contexto> | assistant, system, user | sí |  |
| 2025-9-29/5-22-31-_WsW_Contexto_.json | json | <WsW_Contexto> | assistant, system, user | sí |  |
| 2025-9-29/5-36-5-_SOP_01___An_lisis__01_.md | md | <SOP_01 - Análisis #01> | assistant, system, user | sí |  |
| 2025-9-29/5-36-5-_SOP_01___An_lisis__01_.json | json | <SOP_01 - Análisis #01> | assistant, system, user | sí |  |
| 2025-9-29/5-52-44-_SOP_01___An_lisis__03_.md | md | <SOP_01 - Análisis #03> | assistant, system, user | sí |  |
| 2025-9-29/5-52-44-_SOP_01___An_lisis__03_.json | json | <SOP_01 - Análisis #03> | assistant, system, user | sí |  |
| 2025-9-29/6-11-18-An_lisis_de_documentaci_n_PS.md | md | Análisis de documentación PS | assistant, system, user | sí |  |
| 2025-9-29/6-11-18-An_lisis_de_documentaci_n_PS.json | json | Análisis de documentación PS | assistant, system, user | sí |  |
| 2025-9-29/6-31-26-Auditor_a_de_configuraci_n.md | md | Auditoría de configuración | assistant, system, user | sí |  |
| 2025-9-29/6-31-26-Auditor_a_de_configuraci_n.json | json | Auditoría de configuración | assistant, system, user | sí |  |
| 2025-9-29/6-34-30-An_lisis_protocolo_auditor_a.md | md | Análisis protocolo auditoría | assistant, system, user | sí |  |
| 2025-9-29/6-34-30-An_lisis_protocolo_auditor_a.json | json | Análisis protocolo auditoría | assistant, system, user | sí |  |
| 2025-9-29/6-36-14-An_lisis_y_auditor_a_t_cnica.md | md | Análisis y auditoría técnica | assistant, system, user | sí |  |
| 2025-9-29/6-36-14-An_lisis_y_auditor_a_t_cnica.json | json | Análisis y auditoría técnica | assistant, system, user | sí |  |
| 2025-9-29/6-50-15-An_lisis_de_protocolo_SOP01.md | md | Análisis de protocolo SOP01 | assistant, system, tool, user | sí |  |
| 2025-9-29/6-50-15-An_lisis_de_protocolo_SOP01.json | json | Análisis de protocolo SOP01 | assistant, system, tool, user | sí |  |