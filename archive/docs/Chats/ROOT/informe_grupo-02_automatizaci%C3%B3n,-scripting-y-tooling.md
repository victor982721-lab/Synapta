# Automatización, scripting y tooling

## Resumen ejecutivo
Este informe sintetiza 4 conversación(es) sobre **Automatización, scripting y tooling**.
Principales intenciones detectadas:
- Analiza y explica que hace el siguiente script: ``` # Patch-Verify_Project_Modularize
- Lee en su totalidad y analiza detalladamente lo siguiente: ~~~~~ # Protocolo de realización de parches a documentos y scripts
- Lee en su totalidad y analiza detalladamente lo siguiente: ~~~~~ # Project Instructions - Repo_AR <ROLE> Automation Engineer Assistant for Document & Script Orchestration, specialized in configuration

## Alcance y supuestos
- Basado exclusivamente en el contenido presente en las conversaciones fuente.
- Se excluyen saludos, disculpas y texto genérico sin valor técnico.
- Se preservan fragmentos técnicos, prompts y código tal como aparecen (con mínimos ajustes de formato).

## Procedimiento paso a paso
⚠️ FALTA: No se detectaron pasos numerados explícitos en las fuentes de este grupo.

## Mejores prompts / plantillas
- ⚠️ FALTA: No se hallaron prompts/plantillas explícitos en las fuentes.

## Ejemplos completos
**Caso de 5-31-12-_SCRIPT___Invoke_RepoReorg_ — <SCRIPT - Invoke-RepoReorg>**

*Entrada (user):*

> Analiza y explica que hace el siguiente script: ``` # Patch-Verify_Project_Modularize.ps1 # Reorganiza el macroscript en módulos con marcadores claros y lo renombra a Verify_Project.ps1. # Crea stub de compatibilidad para Invoke-RepoReorg.ps1, conserva backups y actualiza CHANGELOG. #requires -Version 5.1 Set-StrictMode -Version 3.0 $ErrorActionPreference = 'Stop' # --- Rutas del proyecto (Windows) --- $RepoRootWin = 'C:\Users\VictorFabianVeraVill\Desktop\Repo_AR' $ScriptsDir = Join-Path $RepoRootWin 'SCRIPTS' $OldPath = Join-Path $ScriptsDir 'Invoke-RepoReorg.ps1' $NewPath = Join-Path $ScriptsDir 'Verify_Project.ps1' $BackupsDir = Join-Path $ScriptsDir 'BACKUPS' $ChangelogWin = Join-Path $RepoRootWin 'CHANGELOG.md' # --- Ruta espejo opcional para asistente --- $ChangelogBot = '/mnt/data/Repo_AR/CHANGELOG.md' # --- Utilidades locales del parche --- function New-TS { [DateTime]::UtcNow.ToString('yyyyMMdd_HHmmssfff') } function Ensure-Dir([string]$Path){ if (-not (Test-Path -LiteralPath $Path)) { New-Item -ItemType Directory -Path $Path -Force | Out-Null } (Resolve-Path -LiteralPath $Path).Path } function Write-Utf8NoBom { param([Parameter(Mandatory)][string]$Path,[Parameter(Mandatory)][string]$Content,[switch]$Append) $dir = Split-Path -Parent $Path if ($dir) { Ensure-Dir $dir | Out-Null } $utf8 = New-Object System.Text.UTF8Encoding($false) if ($Append){ [IO.File]::AppendAllText($Path,$Content,$utf8) } else { [IO.File]::WriteAllText($Path,$Content,$utf8) } } # --- Validaciones previas --- Ensure-Dir $ScriptsDir | Out-Null Ensure-Dir $BackupsDir | Out-Null if (-not (Test-Path -LiteralPath $OldPath)) { throw "No existe $OldPath; se requiere para versionar y dejar stub." } # --- Respaldo del archivo actual --- $BackupPath = Join-Path $BackupsDir ("Invoke-RepoReorg_{0}.bak" -f (New-TS)) Copy-Item -LiteralPath $OldPath -Destination $BackupPath -Force # --- Contenido del NUEVO macroscript modular: Verify_Project.ps1 --- $VerifyProjectContent = @' # Verify_Project.ps1 — Auditoría y verificación de proyecto (PAVC-Compat 2025-09) # Uso: # .\Verify_Project.ps1 [-RepoRoot <ruta>] [-RunPSSA] [-RunInlineTests] # Notas: # - Compatible PS 5.1 y 7.x # - No modifica contenido de PI/SOP; valida estructura, normaliza BACKUPS, registra PAVC # - Marcadores de módulos para parches granulares (ReplaceBetweenMarkers) # [BEGIN MODULE: Parameters] [CmdletBinding(SupportsShouldProcess, ConfirmImpact='Medium')] param( [string]$RepoRoot, [switch]$RunInlineTests, [switch]$RunPSSA ) # [END MODULE: Parameters] # [BEGIN MODULE: Globals] Set-StrictMode -Version 3.0 $ErrorActionPreference = 'Stop' $Script:Version = '3.0.0-PAVC' $Script:DefaultRepoRoot = 'C:\Users\VictorFabianVeraVill\Desktop\Repo_AR' $Script:GlobalChangeLogPath = $null $Script:PAVC_Tag = 'PAVC-Compat (2025-09)' # [END MODULE: Globals] # [BEGIN MODULE: IO.Utils] function Write-Utf8NoBom { [CmdletBinding()] param([Parameter(Mandatory)][string]$Path,[Parameter(Mandatory)][string]$Content,[switch]$Append) $dir = Split-Path -Parent $Path if ($dir -and -not (Test-Path -LiteralPath $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } $utf8 = New-Object System.Text.UTF8Encoding($false) if ($Append){ [IO.File]::AppendAllText($Path,$Content,$utf8) } else { [IO.File]::WriteAllText($Path,$Content,$utf8) } } function New-Timestamp { [DateTime]::UtcNow.ToString('yyyyMMdd_HHmmssfff') } function Resolve-RepoRoot { [CmdletBinding()] param([string]$RepoRoot) if ([string]::IsNullOrWhiteSpace($RepoRoot)) { if ($env:ANASTASIS_REPO_ROOT) { $RepoRoot = $env:ANASTASIS_REPO_ROOT } else { $RepoRoot = $Script:DefaultRepoRoot } } if (-not (Test-Path -LiteralPath $RepoRoot)) { throw [IO.DirectoryNotFoundException]::new("RepoRoot no encontrado: $RepoRoot") } (Resolve-Path -LiteralPath $RepoRoot).Path } function Ensure-Directory { [CmdletBinding()] param([Parameter(Mandatory)][string]$Path) if (-not (Test-Path -LiteralPath $Path)) { New-Item -ItemType Directory -Path $Path -Force | Out-Null } (Resolve-Path -LiteralPath $Path).Path } # [END MODULE: IO.Utils] # [BEGIN MODULE: Logging] function Append-GlobalChangeLog { [CmdletBinding()] param([Parameter(Mandatory)][string]$Message,[string]$Extra = $null) if (-not $Script:GlobalChangeLogPath) { return } $hr = ('-'*80) $hdr = ("{0} — Verify_Project v{1} — {2}" -f ([DateTime]::UtcNow.ToString('u')),$Script:Version,$Script:PAVC_Tag) $body = if ($Extra) { "$Message`r`n$Extra" } else { $Message } $entry = "$hr`r`n$hdr`r`n$body`r`n$hr`r`n" Write-Utf8NoBom -Path $Script:GlobalChangeLogPath -Content $entry -Append $mirrorDir = '/mnt/data/Repo_AR' if (Test-Path -LiteralPath $mirrorDir) { $mirror = Join-Path $mirrorDir 'CHANGELOG.md' Write-Utf8NoBom -Path $mirror -Content $entry -Append } } function Write-ChangeLog { [CmdletBinding()] param( [Parameter(Mandatory)][string]$TargetPath, [Parameter(Mandatory)] [ValidateSet('Add','Append','ReplaceFile','Move','CreateStub','ReplaceBetweenMarkers','Other')] [string]$Mode, [ValidateLength(1,4096)][string]$Summary='[No summary]' ) $full = Resolve-Path -LiteralPath $TargetPath -ErrorAction Stop $f = Get-Item -LiteralPath $full $dir = Ensure-Directory -Path (Join-Path $f.DirectoryName 'Changelogs') $ts = [DateTime]::UtcNow $safe = ($f.Name -replace '[^A-Za-z0-9\.\-_]','_') $name = ('{0:yyyyMMdd_HHmmssfff}_{1}_{2}.md' -f $ts,$safe,$Mode) $path = Join-Path $dir $name $doc = @" # Changelog Entry - UTC: $($ts.ToString('u')) - File: $($f.FullName) - Mode: $Mode - Summary: $Summary "@ Write-Utf8NoBom -Path $path -Content $doc Append-GlobalChangeLog -Message ("{0:u} | {1} | {2} | {3}" -f $ts,$f.FullName,$Mode,$Summary) $path } # [END MODULE: Logging] # [BEGIN MODULE: Safety.FenceCheck] function Test-FenceSafety { [CmdletBinding()] param([Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)][string[]]$Path) process { foreach ($p in $Path) { if (-not (Test-Path -LiteralPath $p)) { continue } $text = Get-Content -LiteralPath $p -Raw -Encoding UTF8 $issues = @() $grave = [char]0x60 if ($text -match "$grave{5}") { $issues += 'Uso de 5 backticks detectado; preferir 5 tildes ~~~~~ para artefactos.' } if ($text -match "^\s+['""]@") { $issues += 'Cierre de here-string con indentación: el delimitador debe iniciar en columna 1.' } if ($text -match '-f\s+.*\{.*\}') { $issues += 'Uso de -f con llaves {}; duplicar llaves o evitar -f.' } [PSCustomObject]@{ Path=$p; Issues= if ($issues){$issues -join '; '} else {'<OK>'} } } } } # [END MODULE: Safety.FenceCheck] # [BEGIN MODULE: Reporting.PAVC] function Add-PAVCReport { [CmdletBinding()] param([Parameter(Mandatory)][string]$RepoRoot) $utc = [DateTime]::UtcNow $report = @" ## Contexto verificado — $($utc.ToString('yyyy-MM-dd')) - Campos CI (~1500): [Pendiente] — confirmar en UI. **[UI del usuario]** - Project Instructions (límite/ubicación UI): [Pendiente]. **[UI del usuario]** - Memoria (global vs project-only): [Pendiente]. **[UI del usuario]** - Diferencias por plan: [Pendiente; requiere fuentes]. **[Oficial]** - Notas: verificación con fuentes mediante web.run; este script registra trazabilidad. **[$Script:PAVC_Tag]** "@ $ch = Join-Path $RepoRoot 'CHANGELOG.md' Write-Utf8NoBom -Path $ch -Content "`r`n$report`r`n" -Append $mirrorDir = '/mnt/data/Repo_AR' if (Test-Path -LiteralPath $mirrorDir) { $mirror = Join-Path $mirrorDir 'CHANGELOG.md' Write-Utf8NoBom -Path $mirror -Content "`r`n$report`r`n" -Append } Append-GlobalChangeLog -Message 'Registro PAVC añadido al CHANGELOG.' } # [END MODULE: Reporting.PAVC] # [BEGIN MODULE: Project.Checks] function Invoke-ProjectChecks { [CmdletBinding(SupportsShouldProcess)] param([Parameter(Mandatory)][string]$RepoRoot) $root = Resolve-RepoRoot -RepoRoot $RepoRoot Write-Output ("RepoRoot: {0}" -f $root) # Estructura esperada (rutas reales) $scriptsDir = Ensure-Directory -Path (Join-Path $root 'SCRIPTS') $backupsUpper = Join-Path $scriptsDir 'BACKUPS' $backupsLower = Join-Path $scriptsDir 'Backups' if ((Test-Path -LiteralPath $backupsLower) -and -not (Test-Path -LiteralPath $backupsUpper)) { if ($PSCmdlet.ShouldProcess($backupsLower,'Renombrar a BACKUPS')) { Move-Item -LiteralPath $backupsLower -Destination $backupsUpper -Force Write-ChangeLog -TargetPath $backupsUpper -Mode 'Move' -Summary 'Normalización: SCRIPTS\BACKUPS (mayúsculas)' | Out-Null } } Ensure-Directory -Path $backupsUpper | Out-Null $piPath = Join-Path $root 'Project_Instructions.md' $sopDir = Join-Path $root 'SOP' $sopList = @('SOP_Auditoria_Proyecto.md','SOP_CB_Blindado.md','SOP_Herestrings.md','SOP_AVC.md') | ForEach-Object { Join-Path $sopDir $_ } if (-not (Test-Path -LiteralPath $piPath)) { throw [IO.FileNotFoundException]::new("Falta Project_Instructions.md en $root") } if (-not (Test-Path -LiteralPath $sopDir)) { throw [IO.DirectoryNotFoundException]::new("Falta carpeta SOP en $root") } $missing = $sopList | Where-Object { -not (Test-Path -LiteralPath $_) } if ($missing) { throw ("Faltan SOP: " + ($missing -join ', ')) } # Fence/Here-strings sanity check (reporte) $checkPaths = @($piPath) + $sopList $report = $checkPaths | Test-FenceSafety | Format-Table -AutoSize | Out-String Append-GlobalChangeLog -Message 'Resultados Test-FenceSafety' -Extra $report Add-PAVCReport -RepoRoot $root Write-Output "Verificación aplicada (sin mutaciones de contenido)." } # [END MODULE: Project.Checks] # [BEGIN MODULE: QualityGate] function Get-PesterMajor { $m = Get-Module -ListAvailable -Name Pester | Sort-Object Version -Descending | Select-Object -First 1 if ($m) { $m.Version.Major } else { 0 } } function Get-ThisScriptPath { if ($PSCommandPath) { return $PSCommandPath } if ($MyInvocation.MyCommand.Path) { return $MyInvocation.MyCommand.Path } if ($PSScriptRoot) { return (Join-Path $PSScriptRoot 'Verify_Project.ps1') } return $null } function Invoke-SerintraQualityGate { [CmdletBinding()] param([switch]$RunPSSA = $false,[switch]$RunPesterInline = $false) $hadFailure = $false $scriptPath = Get-ThisScriptPath if ($RunPSSA) { $pssa = Get-Module -ListAvailable -Name PSScriptAnalyzer if ($pssa) { try { Write-Output ">> PSSA: Analizando $scriptPath ..." $results = Invoke-ScriptAnalyzer -Path $scriptPath -Recurse -Severity @('Error','Warning') if ($results) { $hadFailure = $true $results | Select-Object RuleName,Severity,ScriptName,Line,Message | Format-Table -AutoSize | Out-String | Write-Output Append-GlobalChangeLog -Message "PSSA halló hallazgos en $scriptPath" } else { Write-Output ">> PSSA: Sin hallazgos." } } catch { $hadFailure = $true Write-Output ">> PSSA: Error — $($_.Exception.Message)" Append-GlobalChangeLog -Message "PSSA error: $($_.Exception.Message)" } } else { Write-Output ">> PSScriptAnalyzer no está instalado. Sugerido: Install-Module PSScriptAnalyzer -Scope CurrentUser -Force" } } if ($RunPesterInline) { $pv = Get-PesterMajor if ($pv -ge 5) { Write-Output ">> Pester v$pv: ejecutando pruebas inline..." $TempFile = Join-Path $env:TEMP ("temp_protocol_test_{0}.md" -f (New-Timestamp)) @" A # [BEGIN SECTION: test] old # [END SECTION: test] Z "@ | Set-Content -LiteralPath $TempFile -Encoding UTF8 $ScriptBlock = { Describe 'HereStrings Utilities (Inline)' { It 'crea backup en append' { $r = Set-FileContentAppend -Path $using:TempFile -Content "`nappend" -Summary 'test append' ($r.Backup | Test-Path) | Should -BeTrue } It 'reemplaza entre marcadores' { $r = Set-FileContentReplaceBetweenMarkers -Path $using:TempFile -StartMarker '# [BEGIN SECTION: test]' -EndMarker '# [END SECTION: test]' -NewContent "new" -IncludeMarkers ($r.Backup | Test-Path) | Should -BeTrue (Get-Content -LiteralPath $using:TempFile -Raw) | Should -Match 'new' } } } try { $res = Invoke-Pester -Script @{ ScriptBlock = $ScriptBlock } -PassThru if ($res.FailedCount -gt 0) { $hadFailure = $true; Append-GlobalChangeLog -Message "Pester inline: pruebas fallidas." } else { Write-Output ">> Pester: OK." } } finally { Remove-Item -LiteralPath $TempFile -Force -ErrorAction SilentlyContinue } } elseif ($pv -gt 0) { Write-Output ">> Pester v$pv (legacy): sin pruebas inline; actualiza a v5 para ejecutar este gate." } else { Write-Output ">> Pester no está instalado. Sugerido: Install-Module Pester -Scope CurrentUser -Force" } } if ($hadFailure) { throw [Exception]::new('Quality Gate falló (PSSA o Pester).') } } # [END MODULE: QualityGate] # [BEGIN MODULE: Edit.Utils] function New-IncrementalBackup { [CmdletBinding()] param([Parameter(Mandatory)][string]$Path) $full = Resolve-Path -LiteralPath $Path -ErrorAction Stop $f = Get-Item -LiteralPath $full $dir = Ensure-Directory -Path (Join-Path $f.DirectoryName 'BACKUPS') $bak = Join-Path $dir ("{0}_{1}.bak" -f $f.BaseName,(New-Timestamp)) Copy-Item -LiteralPath $f.FullName -Destination $bak -Force $bak } function Set-FileContentAppend { [CmdletBinding()] param([Parameter(Mandatory)][string]$Path,[Parameter(Mandatory)][string]$Content,[string]$Summary='Append content') $backup = New-IncrementalBackup -Path $Path Write-Utf8NoBom -Path $Path -Content $Content -Append $cl = Write-ChangeLog -TargetPath $Path -Mode 'Append' -Summary $Summary [pscustomobject]@{ Backup=$backup; Changelog=$cl; Path=(Resolve-Path $Path).Path } } function Set-FileContentReplaceBetweenMarkers { [CmdletBinding()] param( [Parameter(Mandatory)][string]$Path, [Parameter(Mandatory)][string]$StartMarker, [Parameter(Mandatory)][string]$EndMarker, [Parameter(Mandatory)][string]$NewContent, [switch]$IncludeMarkers, [switch]$All, [string]$Summary='Replace between markers' ) $text = Get-Content -LiteralPath $Path -Raw -Encoding UTF8 $sm = [Regex]::Escape($StartMarker); $em = [Regex]::Escape($EndMarker) $pattern = if ($IncludeMarkers) { "(?s)$sm.*?$em" } else { "(?s)(?<=$sm).*?(?=$em)" } if (-not ([Regex]::IsMatch($text,$pattern))) { throw [ArgumentException]::new("Marcadores no encontrados en $Path") } $backup = New-IncrementalBackup -Path $Path $replacement = if ($IncludeMarkers) { "$StartMarker`r`n$NewContent`r`n$EndMarker" } else { $NewContent } $evaluator = [System.Text.RegularExpressions.MatchEvaluator]{ param($m) $replacement } $newText = if ($All) { [Regex]::Replace($text,$pattern,$evaluator) } else { [Regex]::Replace($text,$pattern,$evaluator,1) } Write-Utf8NoBom -Path $Path -Content $newText $cl = Write-ChangeLog -TargetPath $Path -Mode 'ReplaceBetweenMarkers' -Summary $Summary [pscustomobject]@{ Backup=$backup; Changelog=$cl; Path=(Resolve-Path $Path).Path } } # [END MODULE: Edit.Utils] # [BEGIN MODULE: Orchestration] function Invoke-ProjectVerification { [CmdletBinding(SupportsShouldProcess)] param([string]$RepoRoot) $root = Resolve-RepoRoot -RepoRoot $RepoRoot $Script:GlobalChangeLogPath = Join-Path $root 'CHANGELOG.md' Invoke-ProjectChecks -RepoRoot $root -WhatIf:$false Write-Output "OK — Verify_Project v$Script:Version finalizado. $Script:PAVC_Tag" } # [END MODULE: Orchestration] # [BEGIN MODULE: Entrypoint] try { $resolvedRoot = Resolve-RepoRoot -RepoRoot $RepoRoot Invoke-ProjectVerification -RepoRoot $resolvedRoot -WhatIf:$false Invoke-SerintraQualityGate -RunPSSA:$RunPSSA -RunPesterInline:$RunInlineTests } catch { $msg = "ERROR — $($_.Exception.Message)" Write-Output $msg if ($resolvedRoot) { $Script:GlobalChangeLogPath = Join-Path $resolvedRoot 'CHANGELOG.md' Append-GlobalChangeLog -Message $msg } exit 1 } # [END MODULE: Entrypoint] '@ # --- Stub de compatibilidad para el nombre antiguo --- $StubContent = @' # Invoke-RepoReorg.ps1 (stub de compatibilidad) # Redirige a Verify_Project.ps1 conservando parámetros/argumentos. param([Parameter(ValueFromRemainingArguments=$true)][object[]]$Args) $target = Join-Path $PSScriptRoot 'Verify_Project.ps1' if (-not (Test-Path -LiteralPath $target)) { throw "Verify_Project.ps1 no encontrado en $PSScriptRoot" } & $target @Args '@ # --- Escribir nuevo archivo y stub --- Write-Utf8NoBom -Path $NewPath -Content $VerifyProjectContent Write-Utf8NoBom -Path $OldPath -Content $StubContent # --- Registrar en CHANGELOG (Windows y espejo opcional) --- $logEntry = @" -------------------------------------------------------------------------------- $([DateTime]::UtcNow.ToString('u')) — Reorganización modular y renombrado Backup original: $BackupPath Archivo nuevo : $NewPath Stub creado : $OldPath (redirige a Verify_Project.ps1) Cambios: módulos con marcadores [BEGIN/END MODULE], normalización BACKUPS, reporte PAVC, utilidades de edición y logging, Quality Gate opcional (PSSA/Pester), compatibilidad PS5/PS7. -------------------------------------------------------------------------------- "@ Write-Utf8NoBom -Path $ChangelogWin -Content $logEntry -Append if (Test-Path -LiteralPath (Split-Path -Parent $ChangelogBot)) { Write-Utf8NoBom -Path $ChangelogBot -Content $logEntry -Append } Write-Host "OK — Verify_Project.ps1 creado y macroscript modularizado." Write-Host " Nuevo: $NewPath" Write-Host " Stub : $OldPath" Write-Host " Backup: $BackupPath" ```

*Salida (assistant):*

> Aquí va una lectura técnica y práctica del script **Patch-Verify_Project_Modularize.ps1**. # ¿Qué hace en una frase? Reemplaza el macroscript original **SCRIPTS\Invoke-RepoReorg.ps1** por un nuevo script modular **SCRIPTS\Verify_Project.ps1**, dejando un **stub** con el nombre viejo para compatibilidad, **respalda** el archivo original, y **documenta** los cambios en `CHANGELOG.md` (en el repo y, si existe, en el espejo `/mnt/data/Repo_AR`). --- # Requisitos clave - PowerShell **5.1** mínimo (`#requires -Version 5.1`). - Debe existir `C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SCRIPTS\Invoke-RepoReorg.ps1`. - Permisos de escritura en `Repo_AR` y subcarpetas. --- # Flujo del patch (lo que hace al ejecutarse) 1. **Configura rutas** (Windows) y una **ruta espejo opcional** del CHANGELOG en `/mnt/data/Repo_AR/CHANGELOG.md`. 2. Define utilidades: - `New-TS()` (timestamp UTC). - `Ensure-Dir()` (asegura existencia de carpeta). - `Write-Utf8NoBom()` (escritura UTF-8 **sin BOM**, con/ sin append). 3. **Valida** que exista el script viejo `SCRIPTS\Invoke-RepoReorg.ps1`; si no, **lanza error** y termina. 4. **Respalda** el script viejo a `SCRIPTS\BACKUPS\Invoke-RepoReorg_<UTC>.bak`. 5. **E...

---

**Caso de 6-33-27-An_lisis_de_m_dulos_PowerShell — Análisis de módulos PowerShell**

*Entrada (user):*

> Lee en su totalidad y analiza detalladamente lo siguiente: ~~~~~ # Protocolo de realización de parches a documentos y scripts. --- ## Módulo 1 – INFO - **Objetivo** Encabezado documental del script: define **nombre, sinopsis, propósito, compatibilidad, autor, versión y fecha**. Sirve como bloque de **identidad y trazabilidad**, útil para documentación, control de cambios y auditoría. ~~~~~ ## [BEGIN MODULE: 1-INFO] #requires -Version 5.1 <# .NOMBRE - (Nombre del script o SOP) .SINOPSIS - (Resumen corto en una sola línea) .DESCRIPCION - (Explicación detallada, propósito del SOP o script) .COMPATIBILIDAD - Windows 10/11 - PowerShell 5.1 / 7.x .AUTOR - (Nombre/alias del responsable) .VERSION - 1.0.0 .FECHA - AAAA-MM-DD #> ## [END MODULE: 1-INFO] ~~~~~ --- ## Módulos 2A a 2E – Inicialización del Entorno - **Objetivo general** Estos módulos forman la **fase de inicialización del proyecto**, asegurando que el script arranque en un entorno controlado, con configuración coherente, rutas estándar garantizadas y logging centralizado. Su función es preparar todo antes de que se ejecute cualquier lógica de negocio. --- ### Módulo 2A – INIT-ENV Establece el **modo de ejecución** (`Real` o `Prueba`) y ajusta las preferencias globales de PowerShell. - Auto-detecta el modo desde parámetros o variables de entorno. - En *Real*: detiene al primer error, `DryRun = False`. - En *Prueba*: continúa ante errores, `DryRun = True`, muestra advertencia. - Silencia mensajes innecesarios (`Warning`, `Information`, `Verbose`, `Progress`). - Fuerza la codificación de consola a **UTF-8 sin BOM**. - Expone versión del INIT y el modo efectivo. ~~~~~ ## [BEGIN MODULE: 2A-INIT-ENV] param( [string]$Modo = $null ) Set-StrictMode -Version 3.0 # --- Auto-detección de modo --- if ([string]::IsNullOrWhiteSpace($Modo)) { if ($env:REPO_AR_MODE -eq 'Prueba' -or $env:DEBUG -or $env:DRY_RUN) { $Modo = 'Prueba' } else { $Modo = 'Real' } } $Modo = @('Real','Prueba') | Where-Object { $_ -ieq $Modo } | Select-Object -First 1 if (-not $Modo) { $Modo = 'Real' } # --- Preferencias globales + DRY-RUN --- switch ($Modo) { 'Real' { $PSDefaultParameterValues['*:ErrorAction'] = 'Stop' $ErrorActionPreference = 'Stop' $Global:IsDryRun = $false } 'Prueba' { $PSDefaultParameterValues['*:ErrorAction'] = 'Continue' $ErrorActionPreference = 'Continue' $Global:IsDryRun = $true Write-Warning "Modo PRUEBA activo → se simularán operaciones (dry-run)." } } $PSDefaultParameterValues['*:WarningAction'] = 'SilentlyContinue' $PSDefaultParameterValues['*:InformationAction'] = 'SilentlyContinue' $VerbosePreference = 'SilentlyContinue' $ProgressPreference = 'SilentlyContinue' # --- UTF-8 sin BOM --- try { [Console]::OutputEncoding = New-Object System.Text.UTF8Encoding($false) [Console]::InputEncoding = New-Object System.Text.UTF8Encoding($false) $OutputEncoding = New-Object System.Text.UTF8Encoding($false) } catch { } $Global:InitModuleVersion = '2.1.0' $Global:InitModo = $Modo ## [END MODULE: 2A-INIT-ENV] ~~~~~ --- ### Módulo 2B – INIT-LOG Define `Write-Log`, el **sistema de logging unificado**. - Soporta niveles: `Info`, `Warn`, `Error`, `DryRun`, `Debug`, `Verbose`. - Colorea salida según severidad. - Respeta `-Verbose` y `-Debug` de PowerShell. - Registra en archivo `init_<timestamp>.log` dentro de `VERIFICATION` si está habilitado. - Centraliza los mensajes para todo el proyecto. ~~~~~ ## [BEGIN MODULE: 2B-INIT-LOG] function Write-Log { [CmdletBinding()] param( [Parameter(Mandatory)][ValidateSet('Info','Warn','Error','DryRun','Debug','Verbose')] [string]$Level, [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$Message, [switch]$NoFile ) # Normaliza para registro en archivo (una sola línea) $msg = [string]$Message $msgOneline = ($msg -replace '\s+', ' ').Trim() $prefix = switch ($Level) { 'Info' { '[INFO] ' } 'Warn' { '[WARN] ' } 'Error' { '[ERROR] ' } 'DryRun' { '[DRY-RUN] ' } 'Debug' { '[DEBUG] ' } 'Verbose' { '[VERBOSE] ' } } $text = "$prefix$msg" # Salida a consola (Debug/Verbose respetan preferencias nativas) switch ($Level) { 'Info' { Write-Host $text } 'Warn' { Write-Warning $msg } 'Error' { Write-Error $msg -ErrorAction Stop } 'DryRun' { Write-Host $text -ForegroundColor Yellow } 'Debug' { if ($DebugPreference -ne 'SilentlyContinue') { Write-Host $text -ForegroundColor DarkGray } } 'Verbose' { if ($VerbosePreference -ne 'SilentlyContinue') { Write-Host $text } } } # Log a archivo (independiente del gating de consola) $shouldFileLog = $false if (-not $NoFile -and $Global:InitConfig -and $Global:InitConfig.PSObject.Properties.Name -contains 'LogToFile' -and $Global:InitConfig.LogToFile -and -not $Global:IsDryRun) { $shouldFileLog = $true } if ($shouldFileLog) { $verifyDir = $null if ($Global:InitConfig.PSObject.Properties.Name -contains 'VerifyDir') { $verifyDir = $Global:InitConfig.VerifyDir } if (-not [string]::IsNullOrWhiteSpace($verifyDir)) { # Asegura carpeta (usa Ensure-Dir si existe; fallback básico si no) if (Get-Command -Name Ensure-Dir -ErrorAction SilentlyContinue) { try { Ensure-Dir -Path $verifyDir | Out-Null } catch { } } else { if (-not (Test-Path -LiteralPath $verifyDir)) { try { New-Item -ItemType Directory -Path $verifyDir -Force | Out-Null } catch { } } } # Timestamp de ejecución si no existe if (-not $Global:ExecTS) { $Global:ExecTS = (Get-Date).ToString('yyyyMMdd_HHmmssfff') } $logFile = Join-Path $verifyDir "init_$($Global:ExecTS).log" $timestamp = Get-Date -Format s try { Add-Content -LiteralPath $logFile -Value ("{0} {1}{2}" -f $timestamp, $prefix, $msgOneline) -Encoding utf8 } catch { Write-Warning ("Write-Log: no se pudo escribir en archivo de log: {0}" -f $logFile) } } } } ## [END MODULE: 2B-INIT-LOG] ~~~~~ --- ~~~~~ ## [BEGIN MODULE: 2C-INIT-CHECKS] function Test-PathWritable { [CmdletBinding()] param([Parameter(Mandatory)][string]$Path) if (-not (Test-Path -LiteralPath $Path)) { return $false } if ($Global:IsDryRun) { Write-Log -Level DryRun -Message "Omitida prueba de escritura en '$Path' (modo prueba)." return $true } try { $testFile = Join-Path $Path ('.writetest_{0}.tmp' -f ([guid]::NewGuid())) [IO.File]::WriteAllText($testFile,'x',[Text.UTF8Encoding]::new($false)) Remove-Item -LiteralPath $testFile -Force -ErrorAction Stop return $true } catch { Write-Log -Level Warn -Message "Ruta no escribible: '$Path'. Detalle: $($_.Exception.Message)" return $false } } ## [END MODULE: 2C-INIT-CHECKS] ~~~~~ ~~~~~ ## [BEGIN MODULE: 2D-INIT-PATHS] param( [string]$RepoRoot = $null, [switch]$RunVerification ) # --- Fuente base de RepoRoot (parametro o autodetección) if ([string]::IsNullOrWhiteSpace($RepoRoot)) { if ($PSScriptRoot) { $RepoRoot = $PSScriptRoot } elseif ($PSCommandPath) { $RepoRoot = Split-Path -Parent $PSCommandPath } else { $RepoRoot = (Get-Location).Path } } # --- Carga settings opcionales (.psd1) con validación $settings = $null try { $candidates = @( (Join-Path $RepoRoot 'RepoSettings.psd1'), (Join-Path $RepoRoot 'Config\RepoSettings.psd1') ) foreach ($c in $candidates) { if (Test-Path -LiteralPath $c) { $tmp = Import-PowerShellDataFile -LiteralPath $c -ErrorAction Stop if ($tmp -is [hashtable]) { $settings = $tmp break } else { if (Get-Command Write-Log -ErrorAction SilentlyContinue) { Write-Log -Level Warn -Message "RepoSettings.psd1 no es un hashtable. Ignorado: $c" } } } } } catch { if (Get-Command Write-Log -ErrorAction SilentlyContinue) { Write-Log -Level Warn -Message "No se pudo importar settings: $($_.Exception.Message)" } } # --- Si settings propone RepoRoot y NO vino por parámetro, intentar usarlo if ($settings -and $settings.ContainsKey('RepoRoot') -and -not $PSBoundParameters.ContainsKey('RepoRoot')) { $proposed = [string]$settings.RepoRoot if (-not [string]::IsNullOrWhiteSpace($proposed)) { $RepoRoot = $proposed if (Get-Command Write-Log -ErrorAction SilentlyContinue) { Write-Log -Level Info -Message "RepoRoot sobreescrito por settings: $RepoRoot" } } } # --- Conjunto de rutas simuladas en DryRun if (-not $Global:_SimulatedPaths) { $Global:_SimulatedPaths = @() } # --- Garantiza RepoRoot (crear o simular) $repoRootExists = Test-Path -LiteralPath $RepoRoot if (-not $repoRootExists) { if ($Global:IsDryRun) { if (Get-Command Write-Log -ErrorAction SilentlyContinue) { Write-Log -Level DryRun -Message "Crearía RepoRoot: $RepoRoot" } $Global:_SimulatedPaths += $RepoRoot } else { try { if (Get-Command -Name Ensure-Dir -ErrorAction SilentlyContinue) { Ensure-Dir -Path $RepoRoot | Out-Null } else { New-Item -ItemType Directory -Path $RepoRoot -Force | Out-Null } } catch { throw "No se pudo crear RepoRoot '$RepoRoot': $($_.Exception.Message)" } } } # --- Normaliza RepoRoot (si existe usar Resolve-Path, si no, normaliza a ruta absoluta) if (Test-Path -LiteralPath $RepoRoot) { $RepoRoot = (Resolve-Path -LiteralPath $RepoRoot).Path } else { try { $RepoRoot = [IO.Path]::GetFullPath($RepoRoot) } catch { # fallback sin romper } } # --- Rutas estándar $ScriptsDir = Join-Path $RepoRoot 'SCRIPTS' $BackupsDir = Join-Path $ScriptsDir 'BACKUPS' $VerifyDir = Join-Path $RepoRoot 'VERIFICATION' # --- Crear o simular directorios estándar foreach ($dir in @($ScriptsDir,$BackupsDir,$VerifyDir)) { if (-not (Test-Path -LiteralPath $dir)) { if ($Global:IsDryRun) { if (Get-Command Write-Log -ErrorAction SilentlyContinue) { Write-Log -Level DryRun -Message "Crearía directorio: $dir" } $Global:_SimulatedPaths += $dir } else { try { if (Get-Command -Name Ensure-Dir -ErrorAction SilentlyContinue) { Ensure-Dir -Path $dir | Out-Null } else { New-Item -ItemType Directory -Path $dir -Force | Out-Null } } catch { throw "No se pudo crear directorio '$dir': $($_.Exception.Message)" } } } } # --- Marca global si hubo simulaciones de rutas $Global:_HasSimulatedPaths = ($Global:_SimulatedPaths.Count -gt 0) # --- Timestamp de ejecución (UTC) si no existe if (-not $Global:ExecTS) { $Global:ExecTS = [DateTime]::UtcNow.ToString('yyyyMMdd_HHmmssfff') } # --- Exponer rutas/config al resto de módulos $Global:_RepoRoot = $RepoRoot $Global:_ScriptsDir = $ScriptsDir $Global:_BackupsDir = $BackupsDir $Global:_VerifyDir = $VerifyDir $Global:_Settings = $settings $Global:_RunVerification = [bool]$RunVerification # --- Facilitar al logger la ruta de verificación (no fuerza LogToFile) if (-not $Global:InitConfig) { $Global:InitConfig = [ordered]@{} } $Global:InitConfig.VerifyDir = $VerifyDir ## [END MODULE: 2D-INIT-PATHS] ~~~~~ --- ~~~~~ ## [BEGIN MODULE: 2E-INIT-CONFIG] # Híbrido: Prueba = flexible (hashtable); Real = objeto de solo lectura # Requiere módulos previos: 2A-INIT-ENV, 2D-INIT-PATHS, 2B-INIT-LOG # --- Resolver LogToFile desde settings si existe --- $logToFile = $false if ($Global:_Settings -and $Global:_Settings.ContainsKey('LogToFile')) { try { $logToFile = [bool]$Global:_Settings.LogToFile } catch { $logToFile = $false } } # --- Datos base (ya establecidos por los módulos previos) --- $cfgVersion = [string]$Global:InitModuleVersion $cfgModo = [string]$Global:InitModo $cfgIsDryRun = [bool]$Global:IsDryRun $cfgRepoRoot = [string]$Global:_RepoRoot $cfgScripts = [string]$Global:_ScriptsDir $cfgBackups = [string]$Global:_BackupsDir $cfgVerify = [string]$Global:_VerifyDir $cfgExecTS = [string]$Global:ExecTS $cfgRunVerif = [bool]$Global:_RunVerification $cfgSettings = $Global:_Settings if (-not $cfgIsDryRun) { # --- Modo REAL: exponer objeto inmutable (read-only) con propiedades .NET --- if (-not ('RepoInitConfig' -as [type])) { class RepoInitConfig { hidden [string] $_Version hidden [string] $_Modo hidden [bool] $_IsDryRun hidden [string] $_RepoRoot hidden [string] $_ScriptsDir hidden [string] $_BackupsDir hidden [string] $_VerifyDir hidden [string] $_ExecTS hidden [bool] $_RunVerification hidden [hashtable] $_Settings hidden [bool] $_LogToFile hidden [bool] $_IsReadOnly RepoInitConfig( [string]$Version, [string]$Modo, [bool]$IsDryRun, [string]$RepoRoot, [string]$ScriptsDir, [string]$BackupsDir, [string]$VerifyDir, [string]$ExecTS, [bool]$RunVerification, [hashtable]$Settings, [bool]$LogToFile ) { $this._Version = $Version $this._Modo = $Modo $this._IsDryRun = $IsDryRun $this._RepoRoot = $RepoRoot $this._ScriptsDir = $ScriptsDir $this._BackupsDir = $BackupsDir $this._VerifyDir = $VerifyDir $this._ExecTS = $ExecTS $this._RunVerification= $RunVerification # Copia superficial para evitar que cambien la referencia externa if ($Settings) { $this._Settings = @{} + $Settings } else { $this._Settings = @{} } $this._LogToFile = $LogToFile $this._IsReadOnly = $true } [string] Version { get { return $this._Version } } [string] Modo { get { return $this._Modo } } [bool] IsDryRun { get { return $this._IsDryRun } } [string] RepoRoot { get { return $this._RepoRoot } } [string] ScriptsDir { get { return $this._ScriptsDir } } [string] BackupsDir { get { return $this._BackupsDir } } [string] VerifyDir { get { return $this._VerifyDir } } [string] ExecTS { get { return $this._ExecTS } } [bool] RunVerification { get { return $this._RunVerification } } [hashtable] Settings { get { return $this._Settings } } [bool] LogToFile { get { return $this._LogToFile } } [bool] IsReadOnly { get { return $this._IsReadOnly } } } } $Global:InitConfig = [RepoInitConfig]::new( $cfgVersion, $cfgModo, $cfgIsDryRun, $cfgRepoRoot, $cfgScripts, $cfgBackups, $cfgVerify, $cfgExecTS, $cfgRunVerif, $cfgSettings, $logToFile ) } else { # --- Modo PRUEBA: hashtable flexible (mutable) y consistente con acceso por punto --- $Global:InitConfig = [ordered]@{ Version = $cfgVersion Modo = $cfgModo IsDryRun = $cfgIsDryRun RepoRoot = $cfgRepoRoot ScriptsDir = $cfgScripts BackupsDir = $cfgBackups VerifyDir = $cfgVerify ExecTS = $cfgExecTS RunVerification = $cfgRunVerif Settings = $cfgSettings LogToFile = $logToFile IsReadOnly = $false } } # --- Mensaje de salida coherente para ambos modos --- Write-Log -Level Info -Message ("INIT listo. Modo={0}; DryRun={1}; RepoRoot='{2}'; ReadOnly={3}." -f ` $Global:InitConfig.Modo, $Global:InitConfig.IsDryRun, $Global:InitConfig.RepoRoot, ` ($(if ($Global:InitConfig.PSObject.Properties.Name -contains 'IsReadOnly') { $Global:InitConfig.IsReadOnly } else { $true }))) ## [END MODULE: 2E-INIT-CONFIG] ~~~~~

*Salida (assistant):*

> {'content_type': 'model_editable_context', 'model_set_context': '', 'repository': None, 'repo_summary': None, 'structured_context': None}

---

**Caso de 6-44-25-Auditor_a_t_cnica_documento — Auditoría técnica documento**

*Entrada (user):*

> Lee en su totalidad y analiza detalladamente lo siguiente: ~~~~~ # Project Instructions - Repo_AR <ROLE> Automation Engineer Assistant for Document & Script Orchestration, specialized in configuration control, quality gates, traceability, and zero-manual workflows. </ROLE> - Speak in Spanish (MX). Be direct, concise and a bit cynical. - **Objective**: Standardized setup for verified generation/editing of documents and scripts, with traceability and reproducible quality in an individual Windows + PowerShell 5/7 environment. ## Mission Generate and maintain macroscripts and SOPs that enable: - Creating/patching documents via **hardened here-strings**. - Automatically backing up before modifying. - Quality verification with **PSScriptAnalyzer** and **Pester v5** (Quality Gate). - Recording changes in **CHANGELOG.md** immutably. ## Session Contract (mandatory at start) Before producing **the first response** in a session: 1. **Run `SOP_AVCM.md`** (Configuration and Memory Update & Verification) and return its **AVCM summary** in that same turn. 2. **Use `web.run`** for any information with a probability ≥ 10% of being outdated (APIs, prices, news, policies, laws, software versions, etc.), **citing sources** and **explicitly labeling** them as **[Official]** or **[Community/Press]**. 3. **One turn, value**: do not promise future work or “background” work. If something is missing, request it explicitly and deliver what can be done **now**. ## Scope and Limits - **Local execution** (no CI/CD). Compatible with Windows 10/11 and PowerShell 5/7. - Cross-cut standardization: backticks/fences, here-strings, folder structure, parameters, and outputs. - Controlled evolution: every change goes through a documented patch (SOP_Verify_Project). ## Operational Artifacts Policy 1. **Actionable**: executable in console, no extra steps. 2. **Definitive**: a single artifact per turn. 3. **Hardened (CBs and fences)**: - **CB without nested blocks** → **3 backticks** (open/close). - **Document with internal CBs** → **outer wrapper** with **five tildes `~~~~~`** and **internal CBs** with **3 backticks**. **One level only** (no “second level”). - Do not write lines composed **only of `~`** inside the document’s content; tildes are reserved for the outer wrapper in this chat. 4. **Automated**: integrated handling of parameters, paths, dependencies, and directory creation. 5. **Validated**: PSSA (JSON and SARIF) and Pester (NUnit) in `VERIFICATION\`. **Quality Gate**: fails on **PSSA Errors**, Pester failures, or invalid `.psd1` manifests. 6. **Safe**: `.bak` backup beforehand in the same folder (and a mirror in `SCRIPTS\BACKUPS\`). 7. **Modularized**: sections with `[BEGIN MODULE: X]` / `[END MODULE: X]` for segmented updates. 8. **Compatible**: Windows 10/11; PowerShell 5/7. 9. **Traceable**: immutable log in `CHANGELOG.md` with version, date, and description. ## Repo Structure (functional summary) - `Project_Instructions.md` → This document (vision, policies, limits). - `CHANGELOG.md` → Immutable change log. - `PSScriptAnalyzerSettings.psd1` → Central repo PSSA config. - `VERIFICATION\` → Validation outputs (`psscriptanalyzer.json`, `.sarif`, `TestResult.xml`). - `SCRIPTS\GENERADOR\Verify_Project.ps1` → Main macroscript (verification/audit). - `SCRIPTS\Invoke-RepoReorg.ps1` → Compatibility stub (redirects to `Verify_Project.ps1`). - `SCRIPTS\BACKUPS\` → Mirror of `.bak` backups. - `SOP\` (+ `SOP\BACKUPS\`) → Operational procedures (audit, here-strings, patching, etc.). ### Tree structure (reference) ```text Repo_AR\ Project_Instructions.md CHANGELOG.md PSScriptAnalyzerSettings.psd1 VERIFICATION\ psscriptanalyzer.json psscriptanalyzer.sarif TestResult.xml SCRIPTS\ BACKUPS\ GENERADOR\ Verify_Project.ps1 Invoke-RepoReorg.ps1 (alias/compat → calls Verify_Project.ps1) SOP\ BACKUPS\ ``` ## General Workflow 1) **Preparation**: ensure PowerShell 5/7, Pester v5, and PSScriptAnalyzer are installed. 2) **Document Generation/Patching**: - Apply patches with targeted here-strings (entire document or marked modules). - Create a `.bak` backup beforehand. 3) **Verification**: - Run PSSA and Pester with reports in `VERIFICATION\`. - Validate `.psd1` manifests with `Test-ModuleManifest`. 4) **Quality Gate**: - Stop if there are **PSSA Errors**, Pester failures, or invalid manifests. 5) **Traceability**: - Record entries in `CHANGELOG.md` (do not modify previous ones). ## Minimal Verification Run ```powershell pwsh -File "C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\SCRIPTS\GENERADOR\Verify_Project.ps1" -RunPSSA -RunInlineTests # Outputs in: C:\Users\VictorFabianVeraVill\Desktop\Repo_AR\VERIFICATION\ ``` ## Patching Procedure (summary) 1. Identify the **module(s)** to change or the full document. 2. Prepare a here-string patch with markers `[BEGIN MODULE: X]` / `[END MODULE: X]`. 3. Make a `.bak` backup and a mirror in `SCRIPTS\BACKUPS\`. 4. Apply the patch (targeted replacement). 5. Run verification (PSSA/Pester/Manifests). 6. Update `CHANGELOG.md` (version, date, description). > More detail in `SOP_Verify_Project.md` and `SOP_PatchEngine.md`. ## INIT — contracts, order, and responsibilities (summary) **Recommended order:** 1-INFO → 2A-INIT-ENV → 2B-INIT-LOG → 2C-INIT-CHECKS → 2D-INIT-PATHS → 2E-INIT-CONFIG - **1-INFO**: metadata (name, synopsis, compatibility, author, version, date). - **2A-INIT-ENV**: Real/Test mode (autodetection via environment variables), error handling (`Stop`/`Continue`), base silencing and UTF-8 without BOM; publishes `InitModuleVersion`, `InitModo`. - **2B-INIT-LOG**: unified `Write-Log` (Info/Warn/Error/DryRun/Debug/Verbose), honors native preferences; log to `VERIFICATION\init_<ExecTS>.log` if `LogToFile` and not DryRun. - **2C-INIT-CHECKS**: write diagnostics (`.tmp` in Real; simulated in Test). - **2D-INIT-PATHS**: resolves `RepoRoot`, loads a valid `RepoSettings.psd1`, ensures (or simulates) `SCRIPTS\`, `SCRIPTS\BACKUPS\`, `VERIFICATION\`; normalizes paths; set of useful globals. - **2E-INIT-CONFIG**: consolidates into `InitConfig`; **Real** → immutable object; **Test** → mutable hashtable; state log. ## Module and Patch Conventions - **Mandatory** module markers: ```text ## [BEGIN MODULE: <Name>] ...content... ## [END MODULE: <Name>] ``` - Recommended prefixes: numbering like `2A`, `2B`, `3A`… for logical order. - Patches: here-strings targeted **only** inside markers. **Never** overwrite outside. - Backups: `.bak` local + mirror in `SCRIPTS\BACKUPS\` before modifying. ## Verification and Reports - **PSScriptAnalyzer** - Config: `PSScriptAnalyzerSettings.psd1` - Outputs: `VERIFICATION\psscriptanalyzer.json` and `.sarif` - **Pester v5** - Minimal inline tests + per-file suites where applicable - Output: `VERIFICATION\TestResult.xml` (NUnit) - **Manifests** - `Test-ModuleManifest` on relevant `.psd1` files - **Gate**: if anything fails, **stop** execution/delivery. ## Versioning and CHANGELOG - SemVer for scripts/SOPs (`MAJOR.MINOR.PATCH`). - `CHANGELOG.md`: immutable entries (append-only) with **date**, **version**, and **reason**. - The `1-INFO` module must reflect the artifact’s effective version/date. ## Packaging to GUI/.EXE (when applicable) - **Real** publishes **read-only** configuration → single-state guarantee. - Logger writes to `VERIFICATION\` with `init_<ExecTS>.log`. - **Test** is for lab/simulations (mutable). - The GUI orchestrates order using **the same modules**. ## Style Standards - UTF-8 **without BOM** (console and files). - Here-string closing at **column 1** (no spaces). - `Set-StrictMode -Version 3.0` in INIT. - Use `Write-Log` for all operational messages (avoid loose `Write-Host`). ## Quick Checklist Before Delivering - [ ] Patch with `~~~~~` fence (wrapper) and correct modules. - [ ] `.bak` backup + mirror in `SCRIPTS\BACKUPS\`. - [ ] PSSA and Pester ran; artifacts in `VERIFICATION\`. - [ ] Gate is green (no errors/failures). - [ ] `CHANGELOG.md` updated. - [ ] `1-INFO` fields up to date (version/date). - [ ] Correct mode (Real for delivery, Test for lab only). ## Mandatory Cross-References Between Documents - **SOP_AVCM** (mandatory before the first response of each session): `SOP\SOP_AVCM.md` - **SOP_Auditoría** (project assessment): `SOP\SOP_Auditoria.md` - **SOP Blindado** (CB and here-string policy): `SOP\SOP_CB_Blindado.md` - **SOP_Verify_Project** (verification and quality gate): `SOP\SOP_Verify_Project.md` - **SOP_PatchEngine** (full or per-module patching): `SOP\SOP_PatchEngine.md` ## Final Notes - These instructions **mandate** running `SOP_AVCM.md` and using `web.run` as stated in the **Session Contract**. - Keeping CBs as per the policy avoids rendering paradoxes and ensures **copyable** content. ~~~~~

*Salida (assistant):*

> Aquí va una **auditoría técnica puntual** del documento **Project Instructions – Repo_AR** que compartiste. No usé fuentes externas. # Resumen ejecutivo El documento está **bien orientado** (control, trazabilidad, gate de calidad y operación local con PowerShell 5/7). La lógica de “un turno = un artefacto definitivo” y el **Quality Gate** con PSSA/Pester están claros. Los mayores riesgos prácticos son: **UTF-8 sin BOM en PS 5.1**, detalles operativos de **backups atómicos y espejos**, criterios exactos de **gate (qué es “Error”)**, y **parametrización/descubrimiento de modo Real/Test**. Hay además algunos puntos menores de ambigüedad que, si se corrigen, reducen fricciones en la ejecución. --- # Fortalezas (lo que ya está bien) - **Contrato de sesión** claro: web.run para temas volátiles, un turno con valor, sin trabajo en segundo plano. - **Política de artefactos** (fences/CB/here-strings) consistente para evitar “romper” el copiado. - **Estandarización de verificación** (PSSA + Pester + manifests) con outputs en `VERIFICATION\`. - **Trazabilidad**: `CHANGELOG.md` inmutable + módulo `1-INFO` sincronizado. - **Parches por módulos** con marcadores `[BEGIN/END MODULE]`, sin anidación...

---

**Caso de 6-45-32-An_lisis_README_proyecto — Análisis README proyecto**

*Entrada (user):*

> Lee en su totalidad y analiza detalladamente lo siguiente: ~~~~~ # Proyecto "Anastasis_Revenari" — README ## CONTEXTO <ROL> - Actúa como un programador especializado en **PowerShell 7 para Windows 10** - Diseñas, desarrollas y optimizas flujos de trabajo inteligentes, en coherencia con las necesidades y objetivos del usuario. - Esos flujos abarcan desde la generación y edición de scripts hasta la creación de módulos, documentación técnica y entornos de prueba. - Trabajas con un enfoque basado en la automatización, la modularización y la consistencia como prioridades fundamentales. </ROL> idad y automatización razonable. Entorno objetivo: **Windows 10 + PowerShell 5.1** (evitar cmdlets exclusivos de PowerShell 7+). > Nota: Este README no impone un mecanismo de lectura específico; basta **revisar** los archivos del proyecto (`Contexto.md`, `RED.md`, `Vic.md`, `mensajeinicial.md`) antes de escribir código. ## 2) Objetivo del proyecto Entregar **scripts profesionales, funcionales y seguros** para tareas del entorno del usuario, listos para ejecutar en un solo turno. ## 3) Tono y estilo de respuesta - Sé conciso y directo; **no** prometas trabajo futuro. - Entrega resultados **accionables** y finaliza la petición en el mismo turno. - Limita la conversación: prioriza entregar solución sobre dialogar. - Responde siempre en **español**. ## 4) Flujo de trabajo **Paso 0 (obligatorio)** - Ejecuta `RED-TEMARIO.md`. Luego consulta únicamente las secciones de **RED.md** que el temario indique. **Al iniciar sesión** - Revisa `/mnt/data/Contexto.md` y este `README.md`. **Antes de generar/editar un script** - Revisa `/mnt/data/Vic.md` (especificaciones del equipo). - Revisa `/mnt/data/RED.md` (errores y soluciones canónicas). - Usa `/mnt/data/mensajeinicial.md` como arranque breve si trabajas fuera del proyecto. **Entrega** - Un **único bloque de código** listo para pegar. - Incluir al inicio documentación del script: **propósito, parámetros, ejemplos de uso**. - Validación de entradas y **manejo robusto de errores** (`try/catch`, `-ErrorAction Stop`). ## 5) Estándares de implementación - **Simplicidad y eficiencia**: solo lo necesario para resolver la tarea. - **Optimización de recursos**: preferir cmdlets nativos y evitar procesos paralelos sin control. - **Automatización responsable**: sin extras no solicitados (logs avanzados, notificaciones, telemetría). - **Seguridad**: - Verifica elevación correctamente con `WindowsPrincipal.IsInRole(Administrator)` (ver `RED.md`). **No** usar comprobación por registro. - No modificar el sistema sin validación previa/confirmación explícita. - **Progreso**: mostrarlo solo si la operación es larga (sin sobrecargar). - **Compatibilidad**: garantizar funcionamiento en PowerShell 5.1; mencionar requisitos cuando apliquen. ## 6) Entregables y artefactos - Si el script **genera archivos**, provee **enlace de descarga en ASCII** (ruta local visible, p. ej., `sandbox:/mnt/data/...`). - (Opcional) Registrar artefactos en `artifacts/descargas.md` (ruta, fecha, hash) para persistencia. - Para **documentos** modificados, entregar enlaces de **backup** y **actualizado** (sin bloques de código). ## 7) Política de “Script Canónico” Si el script cumple los requisitos (funcional, seguro, compatible), indícalo como **Script Canónico** y que **puede ejecutarse con confianza**. No agregar nuevas funciones salvo que el usuario lo solicite después y el alcance lo permita. ## 8) Verificación de información Si no estás seguro: 1. Busca primero en los archivos del proyecto. 2. Si falta información, **busca en internet** en fuentes oficiales/primarias. 3. Si persiste la incertidumbre, declara que es **suposición** y explica el límite. ## 9) Edición de archivos de texto Cuando se solicite **modificar un documento** del proyecto (p. ej., `README.md`, `Contexto.md`, `RED.md`, `RED-TEMARIO.md`): - **Backup obligatorio:** antes de tocar nada, crear una copia íntegra con marca de tiempo. - **Aplicar cambios preservando contenido:** por defecto **AÑADIR LOS CAMBIOS** sin borrar secciones existentes, salvo que el requerimiento especifique un reemplazo 1:1. - **Entrega por enlaces:** no imprimir documentos completos en bloques de código. Entregar **dos enlaces de descarga**: (1) backup y (2) archivo actualizado. - **Única excepción:** las **Instrucciones del proyecto** no son un documento; sus modificaciones se entregan en un **bloque de código** con el texto exacto actualizado. - **Nomenclatura y trazabilidad:** los archivos modificados deben guardarse con: - **Backup:** `<NOMBRE>_backup_YYYYMMDD-HHMMSS.md` - **Actualizado:** `<NOMBRE>_actualizado_YYYYMMDD-HHMMSS.md` El `<NOMBRE>` es el identificador corto del documento: `README`, `Contexto`, `RED`, `RED-TEMARIO`, `Vic`, `mensajeinicial`. - **Resolución por alias (sesiones):** cuando el usuario se refiera a “README”, “RED”, “TEMARIO”, “VIC” o “CONTEXTO” (con o sin `.md`), interpretar como **el archivo con ese prefijo** cuyo sufijo de fecha es **más reciente**. Si hay empate, usar el más nuevo por fecha de modificación. - **Bitácora de edición**: anota fecha/hora, archivo afectado, acción (backup/actualización) y enlaces generados. ## 10) Restricciones y “no hacer” Restricciones y “no hacer” - No repetir errores listados en `RED.md`. - No agregar mejoras no solicitadas ni complejidad innecesaria. - No depender de funciones no definidas (p. ej., `Log-Error`) salvo que se incluyan en el mismo script. - No demorar la entrega esperando confirmaciones si el requerimiento es claro. ## 11) Reglas de salida (AutoQA) Antes de enviar **cualquier** script, verifica que cumpla **todas**: 1. **Compatibilidad**: `#requires -Version 5.1` en la primera línea. 2. **Formato único**: entrega en **un bloque de código** (sin texto entre medio). 3. **Cabecera documental**: incluye `.SYNOPSIS`, `.DESCRIPTION`, `.PARAMETER`, `.EXAMPLE`. 4. **Validación**: usa atributos (`Validate*`) y validaciones de runtime cuando aplique. 5. **Errores**: establece `$ErrorActionPreference = 'Stop'` y maneja errores con `try/catch`. 6. **Elevación opcional**: expón `-RequireAdmin`; si se solicita y no hay admin, **lanza** un error terminante (no `Write-Error` pasivo). 7. **PS 5.1 puro**: no usar cmdlets exclusivos de PS7+; si no hay alternativa razonable, **explica la limitación**. 8. **Sin dependencias implícitas**: no requerir funciones/módulos no definidos o no estándar. 9. **Artefactos**: si se crean archivos/carpetas, imprime la **ruta final** (enlace ASCII). 10. **Etiqueta**: si cumple, marca **Script Canónico**. 11. **Salida limpia**: NO usar Write-Host; devolver objetos o Write-Verbose (si el usuario ejecuta con -Verbose). ## 12) Comportamientos por defecto (aplicación) - **Elevación**: `-RequireAdmin` está **desactivado por defecto**; solo exige admin si la tarea lo necesita. - **Alternativa PS 5.1**: cuando el usuario pida algo que naturalmente es PS7+, ofrecer variante PS 5.1 o explicar límite. - **Progreso**: muéstralo solo en operaciones largas. - **Salida limpia**: evita verbosidad innecesaria; retorna objetos o información útil para el usuario. --- ## Política **Preflight primero** y **Progreso visible** (añadido 20250918-051429) **Obligatorio para todos los scripts PowerShell del proyecto:** 1. **Preflight al inicio** (antes de cualquier acción): validación de elevación (WindowsPrincipal), existencia de orígenes y destinos, espacio libre por unidad destino, disponibilidad de binarios externos (p. ej., `winfr`, `photorec_win.exe`). 2. **Confirmación explícita** tras el preflight. El script **no ejecuta** acciones hasta que el usuario confirme (o use `-Force`). 3. **Progreso visible**: uso de `Write-Progress` (PS 5.1) para indicar avance global por lotes y por unidad, además de `Write-Verbose` para detalle. Prohibido `Write-Host`. 4. **Salida limpia**: devolver objetos al finalizar y registrar bitácoras/índices en `SESSION_INFO.txt` dentro de la ruta de sesión. 5. **Opción de solo verificación** (`-PreflightOnly`) opcional para auditorías. ### Ejemplo mínimo ```powershell # Recomendado: el script realiza preflight, muestra los checks y pide confirmación .\Invoke-DeepRecovery.DOCS.ps1 -SourceDrives C -DestinationDrives D,E -Engine WinFR -Verbose ``` ## Edición - **NO usar `Write-Host`** en ningún script; preferir salida por objetos o `Write-Verbose`. ~~~~~

*Salida (assistant):*

> Va: leí todo el README y lo desarmé. Aquí tienes un dictamen claro y accionable. # Resumen ejecutivo - El README está **bien encaminado** (prioriza PS 5.1, un-turno, “Script Canónico”, sin `Write-Host`, preflight y trazabilidad por backups/enlaces). - Hay **inconsistencias** y **huecos operativos** que causarán fricción: PS7 vs PS5.1, una línea rota, verbos contradictorios (“ejecuta” un .md), duplicados de texto y reglas sin mecanismo de verificación automática. - Con **parches menores** + una sección de “AutoQA ejecutable” (PSScriptAnalyzer/Pester) quedaría sólido. --- # Fortalezas - **Entrega en un turno** y foco en **artefactos accionables**. - **Compatibilidad PS 5.1** y guía explícita anti-errores (`-ErrorAction Stop`, `try/catch`, validaciones, `-RequireAdmin`, `Write-Progress`, `Write-Verbose`). - **Política de edición** con **backup + actualizado** y **nomenclatura con timestamp**. - **Preflight** obligatorio y opción `-PreflightOnly` — sensato para tareas riesgosas. - **Resolución de alias** para elegir el documento “más reciente”. --- # Inconsistencias / Ambigüedades (priorizadas) **Crítico** 1) **PS7 vs PS5.1.** - ROL dice “especializado en *PowerShell 7 para Windows 10*...

## Snippets de código / comandos
⚠️ FALTA: No se hallaron snippets de código/comandos.

## Checklists
- ⚠️ FALTA: No se detectaron checklists explícitas.

## Errores comunes y cómo evitarlos
- ⚠️ FALTA: No se documentaron errores comunes en las fuentes.

## Métricas o criterios de calidad
- ⚠️ FALTA: No se identificaron métricas/criterios de calidad explícitos.

## Apéndice: notas y decisiones de fusión
- Canonical: **5-31-12-_SCRIPT___Invoke_RepoReorg_** ← 5-31-12-_SCRIPT___Invoke_RepoReorg_(len=53036). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-33-27-An_lisis_de_m_dulos_PowerShell** ← 6-33-27-An_lisis_de_m_dulos_PowerShell(len=59872). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-44-25-Auditor_a_t_cnica_documento** ← 6-44-25-Auditor_a_t_cnica_documento(len=38558). Nota: Agrupación por similitud Jaccard de shingles (k=5).
- Canonical: **6-45-32-An_lisis_README_proyecto** ← 6-45-32-An_lisis_README_proyecto(len=36247). Nota: Agrupación por similitud Jaccard de shingles (k=5).

## Mapa de trazabilidad (este informe)

| archivo_original | formato | título/tema detectado | rol(es) relevantes | porción aprovechada (sí/no) | observaciones de deduplicación |
|---|---|---|---|---|---|
| 2025-9-29/5-31-12-_SCRIPT___Invoke_RepoReorg_.md | md | <SCRIPT - Invoke-RepoReorg> | assistant, system, user | sí |  |
| 2025-9-29/5-31-12-_SCRIPT___Invoke_RepoReorg_.json | json | <SCRIPT - Invoke-RepoReorg> | assistant, system, user | sí |  |
| 2025-9-29/6-33-27-An_lisis_de_m_dulos_PowerShell.md | md | Análisis de módulos PowerShell | assistant, system, user | sí |  |
| 2025-9-29/6-33-27-An_lisis_de_m_dulos_PowerShell.json | json | Análisis de módulos PowerShell | assistant, system, user | sí |  |
| 2025-9-29/6-44-25-Auditor_a_t_cnica_documento.md | md | Auditoría técnica documento | assistant, system, user | sí |  |
| 2025-9-29/6-44-25-Auditor_a_t_cnica_documento.json | json | Auditoría técnica documento | assistant, system, user | sí |  |
| 2025-9-29/6-45-32-An_lisis_README_proyecto.md | md | Análisis README proyecto | assistant, system, user | sí |  |
| 2025-9-29/6-45-32-An_lisis_README_proyecto.json | json | Análisis README proyecto | assistant, system, user | sí |  |