```powershell
#Requires -Version 7.0
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

param(
  # Carpeta donde están los .md (tú ya la tienes así)
  [string]$Root = 'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software',
  # Patrón de archivos .md a procesar
  [string[]]$Patterns = @('YSD300AN.md','YSD300AN-P2406.md'),
  # Carpeta de salida (se crea si no existe)
  [string]$OutDir = (Join-Path $Root 'i18n_work')
)

# ---------- Utilidades ----------
[System.Text.Encoding]::RegisterProvider([System.Text.CodePagesEncodingProvider]::Instance) | Out-Null
$encGB18030 = [System.Text.Encoding]::GetEncoding('GB18030')
$encLatin1  = [System.Text.Encoding]::GetEncoding('ISO-8859-1')

# Tabla rápida de UI común en inglés (se mantiene aunque haya chino)
$UiWhitelist = @(
  'OK','Cancel','Apply','Close','Help','Open','Save','Yes','No','Retry','Abort','Ignore',
  'Next','Back','Finish','Browse','Start','Stop','Connect','Disconnect','Port','COM',
  'Baud','Baud Rate','Bits','Parity','Stop Bits','Data Bits','Language','Chinese','English',
  'Device','Status','Error','Warning','Information','Settings','Options','Default','Reset',
  'Print','Export','Import','About','Version','File','Edit','View','Tools','Window'
)

# Regex de filtros
$reCJK   = '\p{IsCJKUnifiedIdeographs}'                      # hay chino
$reAsciiAllowed = '[\p{IsBasicLatin}\t \-\_\.\,\:\;\(\)\[\]\{\}\/\\\+\=\!\?%°\|]+'  # segmentos ASCII imprimibles
$reTitleUI = '^(?:[A-Z][a-z]+(?: [A-Z][a-z]+){0,4})$'        # Título de 1 a 5 palabras
$rePathLike = '(?:[A-Za-z]:\\|\\|/|\.exe\b|\.dll\b|\.sys\b|\\\\)' # rutas/ejecutables
$reGuid  = '\b[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}\b'

function New-Row {
  param($file,$encoding,$offset,$text,$class)
  $norm = ($text -replace '\s+',' ' ).Trim()
  if ($norm.Length -eq 0) { return $null }
  [pscustomobject]@{
    File      = $file
    Encoding  = $encoding
    Offset    = $offset
    Length    = $norm.Length
    Text      = $norm
    Class     = $class
    Id        = (Get-FileHash -InputStream ([System.IO.MemoryStream]::new([byte[]][char[]]$norm)) -Algorithm SHA256).Hash.Substring(0,16)
  }
}

function Extract-AsciiStrings {
  param([byte[]]$Bytes,[string]$File)
  $s = $encLatin1.GetString($Bytes)
  # trozos ASCII “legibles”
  $matches = [regex]::Matches($s, $reAsciiAllowed)
  foreach ($m in $matches) {
    $t = $m.Value
    # Normalizar espacios
    $t = ($t -replace '[\t\r\n]+',' ' ).Trim(' .')
    if ($t.Length -lt 2 -or $t.Length -gt 60) { continue }
    # Filtros de ruido
    if ($t -match $rePathLike -or $t -match $reGuid) { continue }
    $digitRatio = if ($t.Length) { ($t.ToCharArray() | Where-Object { $_ -match '\d' }).Count / $t.Length } else { 0 }
    if ($digitRatio -gt 0.5) { continue }
    # Candidatos UI ASCII: título, contiene espacio y letras, o está en whitelist
    $looksTitle = $t -match $reTitleUI
    $hasSpace   = $t -match '\S\s+\S'
    $inWhite    = $UiWhitelist -contains $t
    if ($looksTitle -or $hasSpace -or $inWhite) {
      New-Row -file $File -encoding 'ASCII' -offset $m.Index -text $t -class 'ui_en'
    }
  }
}

function Extract-WideAscii {
  param([byte[]]$Bytes,[string]$File)
  # Buscar patrones UTF-16LE: [ascii][00][ascii][00]...
  $out = New-Object System.Collections.Generic.List[object]
  $i = 0
  while ($i -lt ($Bytes.Length - 3)) {
    # ¿empieza secuencia wchar ASCII?
    if ($Bytes[$i] -ge 32 -and $Bytes[$i] -le 126 -and $Bytes[$i+1] -eq 0) {
      $start = $i
      $chars = New-Object System.Collections.Generic.List[string]
      while ($i -lt ($Bytes.Length - 1) -and $Bytes[$i+1] -eq 0 -and $Bytes[$i] -ge 9 -and $Bytes[$i] -le 126) {
        $chars.Add([char]$Bytes[$i])
        $i += 2
      }
      $t = -join $chars
      $t = ($t -replace '[\t\r\n]+',' ' ).Trim(' .')
      if ($t.Length -ge 2 -and $t.Length -le 60 -and $t -notmatch $rePathLike -and $t -notmatch $reGuid) {
        $digitRatio = if ($t.Length) { ($t.ToCharArray() | Where-Object { $_ -match '\d' }).Count / $t.Length } else { 0 }
        if ($digitRatio -le 0.5) {
          $looksTitle = $t -match $reTitleUI
          $hasSpace   = $t -match '\S\s+\S'
          $inWhite    = $UiWhitelist -contains $t
          if ($looksTitle -or $hasSpace -or $inWhite) {
            $out.Add((New-Row -file $File -encoding 'UTF-16LE' -offset $start -text $t -class 'ui_en_wide'))
          }
        }
      }
      continue
    }
    $i++
  }
  $out
}

function Extract-CJK {
  param([byte[]]$Bytes,[string]$File)
  $s = $encGB18030.GetString($Bytes)
  # Secuencias con al menos UN ideograma chino, longitud razonable
  $rx = '(?=(?:.*' + $reCJK + '))' + '[\p{IsBasicLatin}\p{IsCJKUnifiedIdeographs}\p{IsPunctuation}\p{IsNumber}\s]{2,60}'
  $matches = [regex]::Matches($s, $rx)
  foreach ($m in $matches) {
    $t = ($m.Value -replace '[\s\r\n\t]+',' ' ).Trim(' .')
    if ($t.Length -lt 2) { continue }
    # Ruido típico chino: números con unidades sueltas, etc. (suave)
    if ($t -match $rePathLike -or $t -match $reGuid) { continue }
    New-Row -file $File -encoding 'GB18030' -offset $m.Index -text $t -class 'zh'
  }
}

# ---------- Main ----------
if (-not (Test-Path -LiteralPath $OutDir)) { New-Item -ItemType Directory -Path $OutDir | Out-Null }

$targets = foreach($pat in $Patterns){ Get-ChildItem -LiteralPath (Join-Path $Root $pat) -ErrorAction SilentlyContinue }
if (-not $targets) { throw "No se encontraron .md con patrones: $($Patterns -join ', ')" }

$rowsAll = New-Object System.Collections.Generic.List[object]

foreach($f in $targets){
  Write-Host "[*] Procesando $($f.FullName) ..." -ForegroundColor Cyan
  $bytes = [System.IO.File]::ReadAllBytes($f.FullName)

  $rowsAll.AddRange((Extract-AsciiStrings -Bytes $bytes -File $f.Name))
  $rowsAll.AddRange((Extract-WideAscii   -Bytes $bytes -File $f.Name))
  $rowsAll.AddRange((Extract-CJK         -Bytes $bytes -File $f.Name))
}

# Deduplicado por Texto (mantener la primera aparición)
$dedup = @{}
$candidates = foreach($r in $rowsAll){
  if (-not $dedup.ContainsKey($r.Text)) {
    $dedup[$r.Text] = 1
    $r
  } else {
    $dedup[$r.Text]++
  }
}

# Agregar conteo de ocurrencias
$candidates = $candidates | ForEach-Object {
  $_ | Add-Member -NotePropertyName Occurrences -NotePropertyValue $dedup[$_.Text] -PassThru
}

# Orden razonable: chino primero, luego UI ASCII, por longitud asc.
$candidates = $candidates | Sort-Object @{e='Class';asc=$true}, @{e='Length';asc=$true}, 'Text'

# Exports
$csvPath  = Join-Path $OutDir 'strings_candidates.csv'
$jsonPath = Join-Path $OutDir 'strings_candidates.json'
$xlPath   = Join-Path $OutDir 'strings_candidates_work.csv'  # con columna Traduccion

$candidates |
  Select-Object Id,Text,Class,Encoding,File,Offset,Length,Occurrences |
  Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $csvPath

$candidates |
  Select-Object Id,Text,Class,Encoding,File,Offset,Length,Occurrences |
  ConvertTo-Json -Depth 5 | Set-Content -LiteralPath $jsonPath -Encoding UTF8

# Versión “lista para traducir” con columna vacía
$candidates |
  Select-Object Id, @{n='Original';e={$_.Text}}, @{n='Traduccion';e={''}}, Class,File,Encoding,Occurrences |
  Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $xlPath

# Semilla de glosario: palabras ASCII frecuentes de los candidatos
$gloss = $candidates |
  Where-Object { $_.Class -like 'ui_en*' } |
  ForEach-Object {
    ($_.Text -split '[^A-Za-z]+') | Where-Object { $_.Length -ge 3 }
  } | Group-Object | Sort-Object Count -Descending |
  Select-Object @{n='Token';e={$_.Name}}, @{n='Count';e={$_.Count}}

$glossPath = Join-Path $OutDir 'glossary_seed.csv'
$gloss | Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $glossPath

Write-Host ""
Write-Host "[OK] Candidatos listos para traducción:" -ForegroundColor Green
Write-Host "     $csvPath"
Write-Host "     $jsonPath"
Write-Host "     $xlPath (incluye columna Traduccion)"
Write-Host "     Semilla de glosario: $glossPath"
```