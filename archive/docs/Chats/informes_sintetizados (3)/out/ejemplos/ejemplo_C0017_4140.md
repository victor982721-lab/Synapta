```powershell
# extract_strings_from_md.ps1
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# === Entradas fijas a tu caso ===
$Files = @(
  'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\YSD300AN.md',
  'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\YSD300AN-P2406.md'
)
$outDir = 'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\_strings'
New-Item -ItemType Directory -Force -Path $outDir | Out-Null

# === Helpers ===
function Get-PEInfo {
  param([byte[]]$Bytes)
  try {
    $peOff = [BitConverter]::ToInt32($Bytes, 0x3C)
    if ($peOff -lt 0 -or $peOff + 24 -gt $Bytes.Length) { return $null }
    $sig = [System.Text.Encoding]::ASCII.GetString($Bytes, $peOff, 4)
    if ($sig -ne "PE`0`0") { return $null }
    $coff = $peOff + 4
    $numSec = [BitConverter]::ToUInt16($Bytes, $coff + 2)
    $ts    = [BitConverter]::ToUInt32($Bytes, $coff + 4)
    $optSz = [BitConverter]::ToUInt16($Bytes, $coff + 16)
    $sectTbl = $coff + 20 + $optSz
    $secs = @()
    for ($i=0; $i -lt $numSec; $i++){
      $off = $sectTbl + 40*$i
      if ($off + 40 -gt $Bytes.Length) { break }
      $name = ([Text.Encoding]::ASCII.GetString($Bytes, $off, 8)).Trim([char]0)
      $rawPtr  = [BitConverter]::ToUInt32($Bytes,$off+20)
      $rawSize = [BitConverter]::ToUInt32($Bytes,$off+16)
      $va      = [BitConverter]::ToUInt32($Bytes,$off+12)
      $secs += [pscustomobject]@{
        name=$name; raw_ptr=$rawPtr; raw_size=$rawSize; va=("0x{0:X}" -f $va)
      }
    }
    [pscustomobject]@{
      timestamp = ([DateTime]'1970-01-01').AddSeconds($ts).ToString('s')
      sections  = $secs
    }
  } catch { $null }
}

function Get-AsciiStrings {
  param([byte[]]$Bytes,[int]$MinLen=4)
  $list = New-Object System.Collections.Generic.List[object]
  $start=-1; $sb=[Text.StringBuilder]::new()
  for ($i=0; $i -lt $Bytes.Length; $i++){
    $b = $Bytes[$i]
    if (($b -ge 0x20 -and $b -le 0x7E) -or $b -eq 0x09){
      if ($start -lt 0){ $start=$i }
      [void]$sb.Append([char]$b)
    } else {
      if ($sb.Length -ge $MinLen){
        $list.Add([pscustomobject]@{offset=$start; encoding='ascii'; text=$sb.ToString()})
      }
      $sb.Clear() | Out-Null; $start=-1
    }
  }
  if ($sb.Length -ge $MinLen){
    $list.Add([pscustomobject]@{offset=$start; encoding='ascii'; text=$sb.ToString()})
  }
  $list
}

function Get-UnicodeStrings {
  param([byte[]]$Bytes,[int]$MinLen=4)
  $res = New-Object System.Collections.Generic.List[object]
  foreach($align in 0,1){
    $sb=[Text.StringBuilder]::new(); $runStart=-1
    for($i=$align; $i -le $Bytes.Length-2; $i+=2){
      $u = [BitConverter]::ToUInt16($Bytes,$i)
      $ch = [char]$u
      $cat = [Globalization.CharUnicodeInfo]::GetUnicodeCategory($ch)
      $printable = ($u -eq 0x0009) -or ($u -eq 0x0020) -or ($cat -in @(
        'UppercaseLetter','LowercaseLetter','TitlecaseLetter','ModifierLetter','OtherLetter',
        'DecimalDigitNumber','OtherNumber','SpaceSeparator',
        'ConnectorPunctuation','DashPunctuation','OpenPunctuation','ClosePunctuation',
        'InitialQuotePunctuation','FinalQuotePunctuation','OtherPunctuation',
        'MathSymbol','CurrencySymbol','ModifierSymbol','OtherSymbol'))
      if ($printable) {
        if ($runStart -lt 0){ $runStart=$i }
        [void]$sb.Append($ch)
      } else {
        if ($sb.Length -ge $MinLen){
          $res.Add([pscustomobject]@{offset=$runStart; encoding='utf16le'; text=$sb.ToString()})
        }
        $sb.Clear() | Out-Null; $runStart=-1
      }
    }
    if ($sb.Length -ge $MinLen){
      $res.Add([pscustomobject]@{offset=$runStart; encoding='utf16le'; text=$sb.ToString()})
    }
  }
  $res
}

function Write-Outputs {
  param([string]$Path,[byte[]]$Bytes)
  $base = [IO.Path]::GetFileNameWithoutExtension($Path)
  $csv  = Join-Path $outDir "$base`_strings.csv"
  $json = Join-Path $outDir "$base`_strings.json"

  $sha  = (Get-FileHash -Algorithm SHA256 -LiteralPath $Path).Hash
  $pe   = Get-PEInfo -Bytes $Bytes
  $ascii = Get-AsciiStrings   -Bytes $Bytes -MinLen 4
  $uni   = Get-UnicodeStrings -Bytes $Bytes -MinLen 4

  # Combinar, filtrar ruido básico y ordenar por offset
  $all = @($ascii + $uni) |
    Where-Object { $_.text.Trim().Length -ge 4 } |
    Where-Object { $_.text -notmatch '^\p{Zs}+$' } |
    Sort-Object offset, encoding

  # CSV (Excel friendly → UTF-8 BOM)
  $i=0
  $rows = $all | Select-Object @{n='ID';e={ $script:i++; $i }},
                           @{n='Offset';e={ '0x{0:X}' -f $_.offset }},
                           @{n='Encoding';e={$_.encoding}},
                           @{n='Length';e={$_.text.Length}},
                           @{n='Text';e={$_.text}}
  $rows | Export-Csv -NoTypeInformation -Encoding utf8BOM -LiteralPath $csv

  # JSON (incluye meta y top largos para vista rápida)
  $meta = [ordered]@{
    source = $Path
    size_bytes = $Bytes.Length
    sha256 = $sha
    pe_info = $pe
    counts = @{ ascii=$ascii.Count; utf16=$uni.Count; total=$all.Count }
    top_longest = ($all | Sort-Object @{e={$_.text.Length}} -Descending |
                   Select-Object -First 20)
  }
  $obj = [ordered]@{ meta=$meta; strings=$all }
  $obj | ConvertTo-Json -Depth 6 | Out-File -LiteralPath $json -Encoding utf8

  Write-Host "[OK] $base ->" (Split-Path -Leaf $csv) "y" (Split-Path -Leaf $json)
}

# === Proceso ===
foreach($f in $Files){
  if (-not (Test-Path -LiteralPath $f -PathType Leaf)){
    Write-Warning "No existe: $f"; continue
  }
  $bytes = [IO.File]::ReadAllBytes($f)
  Write-Outputs -Path $f -Bytes $bytes
}

Write-Host "`nSalida en: $outDir"
```