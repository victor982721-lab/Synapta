```powershell
# --- CREA New-FileMap.GUI.v4.ps1 EN TU CARPETA ---
$dstDir = 'C:\Users\VictorFabianVeraVill\Desktop\PowerShell'
$dst    = Join-Path $dstDir 'New-FileMap.GUI.v4.ps1'
if (-not (Test-Path -LiteralPath $dstDir)) { New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }

$code = @'
<#
New-FileMap.GUI.v4.ps1  (CSV-first + YSD/EXE/DCY extractor)
- GUI maximizada con tema Claro/Oscuro (oscuro tipo consola).
- FILEMAP a CSV (único formato). JSON/MD deshabilitados.
- Campos mínimos y derivados: relpath, name, ext, is_dir, size_bytes, mtime_iso, ctime_iso, atime_iso,
  mime (simple por extensión), sha256 (opcional), depth, top, parent.
- Filtros avanzados: incluir/excluir extensiones, nombres (comodines), tamaño, fecha, ocultos, symlinks.
- Procesamiento por bloques + progreso. Escritura CSV atómica (.tmp -> final, .bak si existía).
- Carga de CSV para acciones.
- Acciones seguras: mover duplicados por hash, mover por filtro.
  (Acciones limitadas a C:\Users\; mapear/exportar sí funciona en cualquier ruta).
- EXTRACTOR integrado (del script ysd-extract-catalog): lee binarios, calcula SHA-256, extrae cadenas
  ASCII y CP936/GBK con mín. configurables, clasifica heurísticamente, y escribe sólo CSV
  (ysd-catalog.csv) con escritura atómica, ordenado por (file_path, offset), backup .bak, DryRun.
#>

[CmdletBinding(SupportsShouldProcess=$true)]
param([switch]$NoGui)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
if ($PSVersionTable.PSVersion.Major -lt 7) { Write-Warning "Se recomienda PowerShell 7+."; }

# ---------- Utils ----------
function Get-DesktopPath { try { [Environment]::GetFolderPath('Desktop') } catch { Join-Path $env:USERPROFILE 'Desktop' } }
function NowStamp { (Get-Date -Format 'yyyyMMdd_HHmmss') }
function Ensure-Dir([string]$p){ if (-not (Test-Path -LiteralPath $p)) { New-Item -ItemType Directory -Path $p | Out-Null } }
function CsvEscape([string]$s){ if ($null -eq $s) { return '""' }; '"' + ($s -replace '"','""') + '"' }
function ToIso([datetime]$d){ if ($null -eq $d) { "" } else { $d.ToString("s") } }
function Path-NormalizeWin([string]$p){ ($p -replace '/','\').TrimEnd('\') }
function Get-TopFolder([string]$root,[string]$full){
  $rel = [System.IO.Path]::GetRelativePath($root,$full); $rel = $rel -replace '/','\'
  if ($rel -eq '.' -or [string]::IsNullOrWhiteSpace($rel)) { return '' }
  $parts = $rel.Split('\'); if ($parts.Length -gt 0) { return $parts[0] } else { return '' }
}
function Get-ParentRel([string]$rel){
  $rel = $rel.TrimEnd('\'); $idx = $rel.LastIndexOf('\'); if ($idx -ge 0) { return $rel.Substring(0,$idx) } else { return '' }
}
function Simple-MimeByExt([string]$ext){
  if ([string]::IsNullOrWhiteSpace($ext)) { return "" }
  $e = $ext.ToLowerInvariant().TrimStart('.')
  $map = @{
    'txt'='text/plain'; 'md'='text/markdown'; 'csv'='text/csv'; 'json'='application/json'; 'xml'='application/xml';
    'pdf'='application/pdf'; 'doc'='application/msword'; 'docx'='application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    'xls'='application/vnd.ms-excel'; 'xlsx'='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    'ppt'='application/vnd.ms-powerpoint'; 'pptx'='application/vnd.openxmlformats-officedocument.presentationml.presentation';
    'jpg'='image/jpeg'; 'jpeg'='image/jpeg'; 'png'='image/png'; 'gif'='image/gif'; 'bmp'='image/bmp'; 'webp'='image/webp';
    'zip'='application/zip'; '7z'='application/x-7z-compressed'; 'rar'='application/vnd.rar';
    'exe'='application/vnd.microsoft.portable-executable'; 'dll'='application/x-msdownload';
    'ps1'='text/x-powershell'; 'py'='text/x-python'; 'js'='text/javascript'; 'html'='text/html';
  }
  return $map[$e]
}
function Compute-Hash([string]$path,[string]$alg='SHA256'){
  try { (Get-FileHash -LiteralPath $path -Algorithm $alg -ErrorAction Stop).Hash.ToLowerInvariant() } catch { "" }
}
function Ensure-Under-Users([string]$path){
  $allowed = [System.IO.Path]::GetFullPath('C:\Users\')
  $full = [System.IO.Path]::GetFullPath($path)
  return $full.StartsWith($allowed, [System.StringComparison]::OrdinalIgnoreCase)
}
function Atomic-WriteCsv([string]$dest,[string[]]$lines){
  $dir = Split-Path -Path $dest -Parent; Ensure-Dir $dir
  $tmp = "$dest.tmp"; $bak = "$dest.bak"
  if (Test-Path -LiteralPath $dest) {
    try { Move-Item -LiteralPath $dest -Destination $bak -Force -ErrorAction Stop } catch {}
  }
  $enc = New-Object System.Text.UTF8Encoding($false)
  $sw = New-Object System.IO.StreamWriter($tmp,$false,$enc)
  foreach($ln in $lines){ $sw.WriteLine($ln) }
  $sw.Flush(); $sw.Dispose()
  Move-Item -LiteralPath $tmp -Destination $dest -Force
  return $dest
}
function File-Sha256([string]$path){
  try { (Get-FileHash -LiteralPath $path -Algorithm SHA256 -ErrorAction Stop).Hash.ToLowerInvariant() } catch { "" }
}

# ---------- Mapping Core (CSV only) ----------
function New-FileMapCsv {
  [CmdletBinding()]
  param(
    [Parameter(Mandatory)][string]$RootPath,
    [Parameter(Mandatory)][string]$OutDir,
    [switch]$IncludeHidden,
    [switch]$FollowSymlinks,
    [string]$IncludeExt="",
    [string]$ExcludeExt=".tmp,.log,.bak,.map,.pyc,.class",
    [string]$NameInclude="",
    [string]$NameExclude="",
    [double]$MinSizeMB=0,
    [double]$MaxSizeMB=0,
    [datetime]$ModAfter,
    [datetime]$ModBefore,
    [int]$BlockSize=5000,
    [int]$ProgressInterval=500,
    [switch]$ComputeHash
  )
  if (-not (Test-Path -LiteralPath $RootPath)) { throw "No existe la ruta: $RootPath" }
  Ensure-Dir $OutDir
  $ts = NowStamp
  $rootName = Split-Path -Path $RootPath -Leaf; if ([string]::IsNullOrWhiteSpace($rootName)) { $rootName = ($RootPath -replace '[:\\\/]','_') }
  $csvPath = Join-Path $OutDir ("FileList_{0}_{1}.csv" -f ($rootName -replace '[^\w\.-]','_'), $ts)

  $inExts = if ($IncludeExt) { ($IncludeExt -split '[,;]' | % { $_.Trim().ToLowerInvariant() }) } else { @() }
  $exExts = if ($ExcludeExt) { ($ExcludeExt -split '[,;]' | % { $_.Trim().ToLowerInvariant() }) } else { @() }
  $nameIn = if ($NameInclude){ ($NameInclude -split ';' | % { $_.Trim() }) } else { @() }
  $nameEx = if ($NameExclude){ ($NameExclude -split ';' | % { $_.Trim() }) } else { @() }
  $minB = [long]([Math]::Max(0, $MinSizeMB * 1MB)); $maxB = if ($MaxSizeMB -gt 0) { [long]($MaxSizeMB*1MB) } else { 0L }
  $hasModAfter  = $PSBoundParameters.ContainsKey('ModAfter')
  $hasModBefore = $PSBoundParameters.ContainsKey('ModBefore')

  $gci = @{ LiteralPath=$RootPath; Recurse=$true; Force=$true; ErrorAction='SilentlyContinue' }
  if (-not $FollowSymlinks) { $gci['Attributes'] = '!ReparsePoint' }
  $all = @(Get-ChildItem @gci -Force)

  function Pass([System.IO.FileSystemInfo]$fi){
    if (-not $IncludeHidden) {
      if ($fi.Attributes.HasFlag([IO.FileAttributes]::Hidden) -or $fi.Attributes.HasFlag([IO.FileAttributes]::System)) { return $false }
    }
    if ($fi.PSIsContainer) { return $true }
    $ext = $fi.Extension.ToLowerInvariant()
    if ($inExts.Count -gt 0 -and (-not ($inExts -contains $ext))) { return $false }
    if ($exExts.Count -gt 0 -and ($exExts -contains $ext)) { return $false }
    if ($nameIn.Count -gt 0)  { $ok=$false; foreach($pat in $nameIn){ if ($fi.Name -like $pat){$ok=$true;break} }; if(-not $ok){return $false} }
    if ($nameEx.Count -gt 0)  { foreach($pat in $nameEx){ if ($fi.Name -like $pat) { return $false } } }
    if ($fi -is [System.IO.FileInfo]){
      if ($MinSizeMB -gt 0 -and $fi.Length -lt $minB) { return $false }
      if ($MaxSizeMB -gt 0 -and $fi.Length -gt $maxB) { return $false }
      if ($hasModAfter  -and $fi.LastWriteTime -lt $ModAfter)  { return $false }
      if ($hasModBefore -and $fi.LastWriteTime -gt $ModBefore) { return $false }
    }
    return $true
  }

  $items = @($all | Where-Object { Pass $_ })
  $headers = @('relpath','name','ext','is_dir','size_bytes','mtime_iso','ctime_iso','atime_iso','mime','sha256','depth','top','parent')
  $lines = @()
  $lines += ($headers -join ',')

  $total = $items.Count; $processed = 0
  for ($off=0; $off -lt $total; $off += $BlockSize) {
    $end = [Math]::Min($off + $BlockSize - 1, $total - 1)
    $batch = $items[$off..$end]; $i=0
    foreach ($fi in $batch) {
      $i++; $processed++
      if ($i -eq 1 -or ($i % [Math]::Max(50,[int]($ProgressInterval/10)) -eq 0) -or ($processed -eq $total)) {
        $pct = if ($total){ [int](($processed/$total)*100) } else { 100 }
        Write-Progress -Activity 'Mapeando' -Status "$processed / $total" -PercentComplete $pct
      }
      $full = $fi.FullName
      $rel  = [System.IO.Path]::GetRelativePath($RootPath,$full) -replace '/','\'
      if ([string]::IsNullOrWhiteSpace($rel)) { $rel='.' }
      $name = $fi.Name
      $ext  = $fi.Extension.ToLowerInvariant().TrimStart('.')
      $isDir = [bool]$fi.PSIsContainer
      $size = if ($isDir) { 0 } else { [int64]$fi.Length }
      $mtime = ToIso($fi.LastWriteTime)
      $ctime = ToIso($fi.CreationTime)
      $atime = ToIso($fi.LastAccessTime)
      $mime  = if ($isDir) { "" } else { Simple-MimeByExt $ext }
      $sha   = if ($ComputeHash -and -not $isDir) { Compute-Hash $full 'SHA256' } else { "" }
      $depth = ($rel -split '\\').Length - 1
      $top   = Get-TopFolder $RootPath $full
      $parent= Get-ParentRel $rel
      $line = @(
        CsvEscape $rel; CsvEscape $name; CsvEscape $ext; "$isDir"; "$size"; CsvEscape $mtime; CsvEscape $ctime; CsvEscape $atime;
        CsvEscape $mime; CsvEscape $sha; "$depth"; CsvEscape $top; CsvEscape $parent
      ) -join ','
      $lines += $line
    }
  }

  $final = Atomic-WriteCsv $csvPath $lines
  Write-Progress -Activity 'Mapeando' -Completed
  Write-Host "CSV generado: $final"
  $shaCsv = File-Sha256 $final
  if ($shaCsv) { Write-Host "SHA-256(CSV): $shaCsv" }
  return @{ Csv=$final; Count=$items.Count }
}

# ---------- Duplicate move & other actions ----------
function UniqueDest([string]$dir,[string]$name){
  $t=Join-Path $dir $name; if (-not (Test-Path -LiteralPath $t)) { return $t }
  $stem=[System.IO.Path]::GetFileNameWithoutExtension($name); $ext=[System.IO.Path]::GetExtension($name); $i=1
  while($true){ $cand=Join-Path $dir ("{0} ({1}){2}" -f $stem,$i,$ext); if(-not (Test-Path -LiteralPath $cand)){return $cand}; $i++ }
}
function Action-Move-DuplicatesByHash {
  param(
    [Parameter(Mandatory)][object[]]$Rows,
    [Parameter(Mandatory)][string]$DestRoot,
    [ValidateSet('OldestMtime','Alphabetical')][string]$KeepBy = 'OldestMtime'
  )
  if (-not (Ensure-Under-Users $DestRoot)) { throw "Acciones SOLO dentro de C:\Users\. Destino: $DestRoot" }
  Ensure-Dir $DestRoot
  $groups = $Rows | Where-Object { $_.sha256 } | Group-Object sha256
  foreach($g in $groups){
    $items = @($g.Group | Where-Object { $_.relpath -and $_.name -and $_.sha256 } )
    if ($items.Count -le 1) { continue }
    $groupDir = Join-Path $DestRoot $g.Name; Ensure-Dir $groupDir
    $keeper = if ($KeepBy -eq 'Alphabetical') { ($items | Sort-Object relpath)[0] } else { ($items | Sort-Object mtime_iso)[0] }
    foreach($it in $items){
      if ($it -eq $keeper) { continue }
      $srcFull = Join-Path $global:__lastRoot $it.relpath
      if (-not (Ensure-Under-Users $srcFull)) { Write-Host "[SKIP] $srcFull fuera de C:\Users\"; continue }
      if (-not (Test-Path -LiteralPath $srcFull)) { continue }
      $dest = UniqueDest -dir $groupDir -name $it.name
      try { Move-Item -LiteralPath $srcFull -Destination $dest -Force -ErrorAction Stop; Write-Host "[MOVIDO] $srcFull -> $dest" }
      catch { Write-Host "[ERROR] $($_.Exception.Message)" -ForegroundColor Red }
    }
  }
  Write-Host "Destino: $DestRoot"
}
function Action-Move-ByFilter {
  param(
    [Parameter(Mandatory)][object[]]$Rows,
    [Parameter(Mandatory)][string]$DestRoot,
    [string]$IncludeExt="",
    [string]$ExcludeExt="",
    [double]$MinSizeMB=0,
    [double]$MaxSizeMB=0,
    [double]$OlderThanDays=0
  )
  if (-not (Ensure-Under-Users $DestRoot)) { throw "Acciones SOLO dentro de C:\Users\. Destino: $DestRoot" }
  Ensure-Dir $DestRoot
  $inExts = if ($IncludeExt) { ($IncludeExt -split '[,;]' | % { $_.Trim().ToLowerInvariant() }) } else { @() }
  $exExts = if ($ExcludeExt) { ($ExcludeExt -split '[,;]' | % { $_.Trim().ToLowerInvariant() }) } else { @() }
  $minB = [long]([Math]::Max(0, $MinSizeMB*1MB)); $maxB = if ($MaxSizeMB -gt 0) { [long]($MaxSizeMB*1MB) } else { 0L }
  $olderCut = if ($OlderThanDays -gt 0) { (Get-Date).AddDays(-$OlderThanDays) } else { $null }
  foreach($r in $Rows){
    $srcFull = Join-Path $global:__lastRoot $r.relpath
    if (-not (Ensure-Under-Users $srcFull)) { Write-Host "[SKIP] $srcFull fuera de C:\Users\"; continue }
    if (-not (Test-Path -LiteralPath $srcFull -PathType Leaf)) { continue }
    $ext = ([System.IO.Path]::GetExtension($srcFull)).ToLowerInvariant()
    if ($inExts.Count -gt 0 -and (-not ($inExts -contains $ext))) { continue }
    if ($exExts.Count -gt 0 -and ($exExts -contains $ext)) { continue }
    $size = [int64]$r.size_bytes
    if ($MinSizeMB -gt 0 -and $size -lt $minB) { continue }
    if ($MaxSizeMB -gt 0 -and $size -gt $maxB) { continue }
    if ($olderCut -ne $null -and ([datetime]$r.mtime_iso) -gt $olderCut) { continue }
    $dest = UniqueDest -dir $DestRoot -name $r.name
    try { Move-Item -LiteralPath $srcFull -Destination $dest -Force -ErrorAction Stop; Write-Host "[MOVIDO] $srcFull -> $dest" }
    catch { Write-Host "[ERROR] $($_.Exception.Message)" -ForegroundColor Red }
  }
}

# ---------- Extractor (ASCII & CP936) ----------
Add-Type -AssemblyName System.Runtime
try { [System.Text.Encoding]::RegisterProvider([System.Text.CodePagesEncodingProvider]::Instance) } catch {}

function Extract-AsciiStrings {
  param([byte[]]$Bytes,[int]$MinLen=6)
  $buf = New-Object System.Collections.Generic.List[object]
  $start = -1; $i=0; $n=$Bytes.Length
  while($i -lt $n){
    $b = $Bytes[$i]
    $is = ($b -ge 0x20 -and $b -le 0x7E) -or ($b -in 0x09,0x0A,0x0D)
    if ($is){ if ($start -lt 0){ $start=$i } }
    else {
      if ($start -ge 0){
        $len = $i - $start
        if ($len -ge $MinLen){
          $text = [System.Text.Encoding]::ASCII.GetString($Bytes,$start,$len)
          $buf.Add([pscustomobject]@{ offset=$start; byte_len=$len; text=$text; encoding='ascii' })
        }
        $start=-1
      }
    }
    $i++
  }
  if ($start -ge 0){
    $len = $n - $start
    if ($len -ge $MinLen){
      $text = [System.Text.Encoding]::ASCII.GetString($Bytes,$start,$len)
      $buf.Add([pscustomobject]@{ offset=$start; byte_len=$len; text=$text; encoding='ascii' })
    }
  }
  return @($buf)
}

function Extract-CP936Strings {
  param([byte[]]$Bytes,[int]$MinChars=4)
  $enc = [System.Text.Encoding]::GetEncoding(936)
  $res = New-Object System.Collections.Generic.List[object]
  $i=0; $n=$Bytes.Length
  while($i -lt $n-1){
    $b1=$Bytes[$i]; $b2=$Bytes[$i+1]
    $isLead = ($b1 -ge 0x81 -and $b1 -le 0xFE)
    $isTrail= ($b2 -ge 0x40 -and $b2 -le 0xFE -and $b2 -ne 0x7F)
    if ($isLead -and $isTrail){
      $start=$i; $pairs=0
      while($i -lt $n-1){
        $x1=$Bytes[$i]; $x2=$Bytes[$i+1]
        if (($x1 -ge 0x81 -and $x1 -le 0xFE) -and ($x2 -ge 0x40 -and $x2 -le 0xFE -and $x2 -ne 0x7F)){
          $pairs += 1; $i += 2
        } else { break }
      }
      if ($pairs -ge $MinChars){
        $len = $i - $start
        $text = $enc.GetString($Bytes, $start, $len)
        $res.Add([pscustomobject]@{ offset=$start; byte_len=$len; text=$text; encoding='cp936' })
      }
    } else { $i++ }
  }
  return @($res)
}

function Classify-String([string]$text,[string]$enc){
  if ($enc -eq 'cp936'){ return 'state/zh' }
  if ($text -match '[A-Za-z]{4,}') { return 'state/en' }
  if ($text -match '0x[0-9A-Fa-f]{2,}') { return 'constant/pattern' }
  return 'string/heuristic'
}

function Run-Extractor {
  [CmdletBinding(SupportsShouldProcess=$true)]
  param(
    [Parameter(Mandatory)][string]$Target,   # archivo o carpeta
    [switch]$Recurse,
    [int]$AsciiMin=6,
    [int]$CP936Min=4,
    [string]$OutDir,
    [switch]$DryRun
  )
  if (-not (Test-Path -LiteralPath $Target)) { throw "No existe: $Target" }
  if (-not $OutDir) {
    $OutDir = Join-Path (Split-Path -Parent $PSCommandPath) "_out/ysd-catalog"
  }
  Ensure-Dir $OutDir
  $ts = NowStamp
  $csv = Join-Path $OutDir "ysd-catalog_{0}.csv" -f $ts

  $paths = @()
  $item = Get-Item -LiteralPath $Target
  if ($item.PSIsContainer){
    $filter = @{ LiteralPath=$Target; File=$true; ErrorAction='SilentlyContinue'; Force=$true }
    if ($Recurse){ $filter['Recurse']=$true }
    $paths = @(Get-ChildItem @filter | Where-Object { $_.Extension -match '\.(exe|ysd|dcy)$' })
  } else {
    if ($item.Extension -match '\.(exe|ysd|dcy)$'){ $paths=@($item) } else { throw "El archivo no coincide con *.exe;*.ysd;*.dcy" }
  }
  $rows = New-Object System.Collections.Generic.List[string]
  $headers = 'file_path,relpath,name,ext,size_bytes,sha256,encoding,offset,byte_len,classifier,text,timestamp'
  $rows.Add($headers)

  foreach($f in $paths){
    try {
      $bytes = [System.IO.File]::ReadAllBytes($f.FullName)
    } catch {
      Write-Warning "No se pudo leer: $($f.FullName) ($($_.Exception.Message))"; continue
    }
    $sha = File-Sha256 $f.FullName
    $ascii = Extract-AsciiStrings -Bytes $bytes -MinLen $AsciiMin
    $cp936 = Extract-CP936Strings -Bytes $bytes -MinChars $CP936Min
    foreach($s in @($ascii + $cp936)){
      $cls = Classify-String $s.text $s.encoding
      $rel = if ($item.PSIsContainer) { [System.IO.Path]::GetRelativePath($Target,$f.FullName) } else { [System.IO.Path]::GetFileName($f.FullName) }
      $rel = $rel -replace '/','\'
      $line = @(
        CsvEscape $f.FullName; CsvEscape $rel; CsvEscape $f.Name; CsvEscape ($f.Extension.TrimStart('.').ToLowerInvariant());
        "$($f.Length)"; CsvEscape $sha; CsvEscape $s.encoding; "$($s.offset)"; "$($s.byte_len)"; CsvEscape $cls;
        CsvEscape ($s.text.Substring(0,[Math]::Min($s.text.Length,600))); CsvEscape (Get-Date -Format 's')
      ) -join ','
      $rows.Add($line)
    }
  }

  if ($DryRun){
    Write-Host "DryRun: no se escribirá CSV. Candidatos: $($rows.Count-1)"
    return @{ Csv=$csv; Candidates=$rows.Count-1 }
  }

  $final = Atomic-WriteCsv $csv $rows
  $shaCsv = File-Sha256 $final
  Write-Host "CSV extractor: $final"
  if ($shaCsv){ Write-Host "SHA-256(CSV): $shaCsv" }
  $preview = Get-Content -LiteralPath $final -TotalCount 11
  Write-Host "Primeras filas:"; $preview | ForEach-Object { Write-Host $_ }
  return @{ Csv=$final; Count=$rows.Count-1 }
}

# ---------- CLI (no GUI) ----------
if ($NoGui) {
  Write-Host "Modo NoGui: usar funciones New-FileMapCsv y Run-Extractor manualmente." -ForegroundColor Yellow
  return
}

# ---------- GUI ----------
Add-Type -AssemblyName System.Windows.Forms | Out-Null
Add-Type -AssemblyName System.Drawing | Out-Null
$form = New-Object System.Windows.Forms.Form
$form.Text = "New-FileMap v4 (CSV + Extractor)"
$form.WindowState = 'Maximized'
$font = New-Object System.Drawing.Font("Segoe UI",9)
$form.Font = $font
function Add-Label($txt,$x,$y){ $l=New-Object System.Windows.Forms.Label; $l.Text=$txt; $l.Left=$x; $l.Top=$y; $l.AutoSize=$true; $form.Controls.Add($l); $l }
function Add-Text($x,$y,$w){ $t=New-Object System.Windows.Forms.TextBox; $t.Left=$x; $t.Top=$y; $t.Width=$w; $t.Anchor='Top,Left,Right'; $form.Controls.Add($t); $t }
function Add-Btn($txt,$x,$y,$w){ $b=New-Object System.Windows.Forms.Button; $b.Text=$txt; $b.Left=$x; $b.Top=$y; $b.Width=$w; $b.Anchor='Top,Right'; $form.Controls.Add($b); $b }
function Add-Check($txt,$x,$y){ $c=New-Object System.Windows.Forms.CheckBox; $c.Text=$txt; $c.Left=$x; $c.Top=$y; $c.AutoSize=$true; $form.Controls.Add($c); $c }
function Add-Drop($x,$y,$w,$items){ $d=New-Object System.Windows.Forms.ComboBox; $d.Left=$x; $d.Top=$y; $d.Width=$w; $d.DropDownStyle='DropDownList'; $items | % { [void]$d.Items.Add($_) }; $d.SelectedIndex=0; $form.Controls.Add($d); $d }
function Add-Num($x,$y,$w,$min,$max,$val){ $n=New-Object System.Windows.Forms.NumericUpDown; $n.Left=$x; $n.Top=$y; $n.Width=$w; $n.Minimum=$min; $n.Maximum=$max; $n.Value=$val; $form.Controls.Add($n); $n }
function Browse-Folder(){ $fb=New-Object System.Windows.Forms.FolderBrowserDialog; if($fb.ShowDialog() -eq 'OK'){ return $fb.SelectedPath } return $null }
function Browse-OpenFile(){ $fd=New-Object System.Windows.Forms.OpenFileDialog; $fd.Filter="CSV|*.csv|Todos|*.*"; if($fd.ShowDialog() -eq 'OK'){ return $fd.FileName } return $null }

# Theme
Add-Label "Tema:" 20 12 | Out-Null
$ddTheme = Add-Drop 65 8 120 @('Light','Dark'); $ddTheme.SelectedItem='Light'
function Apply-Theme([System.Windows.Forms.Control]$ctrl,[string]$mode){
  $dark = ($mode -eq 'Dark')
  $bg  = if ($dark) { [System.Drawing.Color]::FromArgb(18,18,18) } else { [System.Drawing.SystemColors]::Control }
  $fg  = if ($dark) { [System.Drawing.Color]::White } else { [System.Drawing.Color]::Black }
  $tb  = if ($dark) { [System.Drawing.Color]::FromArgb(32,32,32) } else { [System.Drawing.Color]::White }
  $btn = if ($dark) { [System.Drawing.Color]::FromArgb(45,45,45) } else { [System.Drawing.SystemColors]::Control }
  $ctrl.BackColor=$bg; $ctrl.ForeColor=$fg
  foreach($c in $ctrl.Controls){
    try { $c.ForeColor=$fg; if ($c -is [System.Windows.Forms.TextBox]){ $c.BackColor=$tb } elseif ($c -is [System.Windows.Forms.Button]){ $c.BackColor=$btn; $c.FlatStyle='Flat'; $c.FlatAppearance.BorderColor=$fg } } catch {}
  }
}
$ddTheme.Add_SelectedIndexChanged({ Apply-Theme $form $ddTheme.SelectedItem }); Apply-Theme $form $ddTheme.SelectedItem

# Paths
Add-Label "Ruta raíz:" 200 12 | Out-Null
$tbRoot = Add-Text 275 8  900
$btnRoot = Add-Btn "Examinar..." 1200 7 120; $btnRoot.Add_Click({ $p=Browse-Folder; if($p){ $tbRoot.Text=$p } })

Add-Label "Salida en:" 20 44 | Out-Null
$tbOut = Add-Text 95 40  1030
$btnOut = Add-Btn "Examinar..." 1200 39 120; $btnOut.Add_Click({ $p=Browse-Folder; if($p){ $tbOut.Text=$p } })
$tbOut.Text = Get-DesktopPath

# Options
$cbHidden = Add-Check "Incluir ocultos/Sistema" 20 78
$cbFollow = Add-Check "Seguir symlinks" 200 78
Add-Label "BlockSize:" 340 80 | Out-Null
$numBlock = Add-Num 410 76 80 100 500000 5000
Add-Label "Progreso cada:" 500 80 | Out-Null
$numProg = Add-Num 600 76 80 50 1000000 500
$cbHash = Add-Check "SHA-256" 690 78

Add-Label "Incluir extensiones (.zip;.iso):" 20 110 | Out-Null
$tbInc = Add-Text 230 106 1000
Add-Label "Excluir extensiones:" 20 140 | Out-Null
$tbExc = Add-Text 230 136 1000; $tbExc.Text = ".tmp,.log,.bak,.map,.pyc,.class"
Add-Label "Nombre incluye (*.zip;*.iso):" 20 170 | Out-Null
$tbNInc = Add-Text 230 166 1000
Add-Label "Nombre excluye:" 20 200 | Out-Null
$tbNExc = Add-Text 230 196 1000
Add-Label "Tamaño mín (MB):" 20 230 | Out-Null
$numMin = Add-Num 130 226 80 0 100000 0
Add-Label "Tamaño máx (MB):" 220 230 | Out-Null
$numMax = Add-Num 330 226 80 0 100000 0

# Dates
$cbAfter = Add-Check "Modificado DESPUÉS de:" 430 228
$dtAfter = New-Object System.Windows.Forms.DateTimePicker; $dtAfter.Left=590; $dtAfter.Top=224; $dtAfter.Width=120; $dtAfter.Format='Short'; $form.Controls.Add($dtAfter)
$cbBefore = Add-Check "Modificado ANTES de:" 720 228
$dtBefore = New-Object System.Windows.Forms.DateTimePicker; $dtBefore.Left=880; $dtBefore.Top=224; $dtBefore.Width=120; $dtBefore.Format='Short'; $form.Controls.Add($dtBefore)

# Run mapping
$btnRun = Add-Btn "Mapear → CSV" 20 260 160
$btnOpen = Add-Btn "Abrir salida" 190 260 150; $btnOpen.Enabled=$false

$pb = New-Object System.Windows.Forms.ProgressBar; $pb.Left=20; $pb.Top=292; $pb.Width=1200; $pb.Height=20; $pb.Minimum=0; $pb.Maximum=100; $pb.Anchor='Top,Left,Right'; $form.Controls.Add($pb)
$lbl = New-Object System.Windows.Forms.Label; $lbl.Left=20; $lbl.Top=316; $lbl.Width=1200; $lbl.Text=""; $lbl.Anchor='Top,Left,Right'; $form.Controls.Add($lbl)

# Actions area
$gy = 340
$sep = New-Object System.Windows.Forms.Label; $sep.Left=20; $sep.Top=$gy; $sep.Width=1200; $sep.Height=1; $sep.BorderStyle='Fixed3D'; $sep.Anchor='Top,Left,Right'; $form.Controls.Add($sep)
$gy += 10
$btnLoad = Add-Btn "Cargar CSV..." 20 $gy 160
$btnDup  = Add-Btn "Mover duplicados (hash)" 190 $gy 220; $btnDup.Enabled=$false
Add-Label "Destino acciones:" 420 ($gy+3) | Out-Null
$tbDest = Add-Text 530 $gy 690; $tbDest.Text = (Join-Path (Get-DesktopPath) "Duplicates_SHA256")

$gy += 40
$btnMoveF = Add-Btn "Mover por filtro" 20 $gy 160
Add-Label "inc ext:" 190 ($gy+3) | Out-Null
$tbAFInc = Add-Text 240 $gy 150
Add-Label "exc ext:" 400 ($gy+3) | Out-Null
$tbAFExc = Add-Text 460 $gy 150
Add-Label "mín MB:" 620 ($gy+3) | Out-Null
$numAFMin = Add-Num 680 $gy 60 0 100000 0
Add-Label "máx MB:" 745 ($gy+3) | Out-Null
$numAFMax = Add-Num 805 $gy 60 0 100000 0
Add-Label "≥ días:" 870 ($gy+3) | Out-Null
$numAFAge = Add-Num 920 $gy 60 0 36500 0

# Extractor area
$gy += 50
$sep2 = New-Object System.Windows.Forms.Label; $sep2.Left=20; $sep2.Top=$gy; $sep2.Width=1200; $sep2.Height=1; $sep2.BorderStyle='Fixed3D'; $sep2.Anchor='Top,Left,Right'; $form.Controls.Add($sep2)
$gy += 10
Add-Label "Extractor (EXE/YSD/DCY):" 20 $gy | Out-Null
Add-Label "Objetivo:" 160 $gy | Out-Null
$tbXT = Add-Text 220 $gy 800
$btnXT = Add-Btn "Examinar..." 1030 $gy 120; $btnXT.Add_Click({ $p=Browse-Folder; if($p){ $tbXT.Text=$p } })
$gy += 28
$cbRec = Add-Check "Recurse" 220 $gy
Add-Label "ASCII min:" 290 $gy | Out-Null
$numAM = Add-Num 360 $gy 60 1 200 6
Add-Label "CP936 min:" 430 $gy | Out-Null
$numCM = Add-Num 510 $gy 60 1 200 4
$cbDry = Add-Check "Dry-run" 580 $gy
$gy += 28
$btnRunX = Add-Btn "Ejecutar extractor → CSV" 220 $gy 220

$global:__lastRows = @(); $global:__lastRoot = ""

# Theme apply
Apply-Theme $form $ddTheme.SelectedItem

# Wire mapping
$btnRun.Add_Click({
  if (-not (Test-Path -LiteralPath $tbRoot.Text)) { [System.Windows.Forms.MessageBox]::Show("La ruta raíz no existe."); return }
  $params = @{
    RootPath=$tbRoot.Text.Trim(); OutDir=$tbOut.Text.Trim()
    IncludeHidden=$cbHidden.Checked; FollowSymlinks=$cbFollow.Checked
    IncludeExt=$tbInc.Text.Trim(); ExcludeExt=$tbExc.Text.Trim(); NameInclude=$tbNInc.Text.Trim(); NameExclude=$tbNExc.Text.Trim()
    MinSizeMB=[double]$numMin.Value; MaxSizeMB=[double]$numMax.Value; BlockSize=[int]$numBlock.Value; ProgressInterval=[int]$numProg.Value
    ComputeHash=$cbHash.Checked
  }
  if ($cbAfter.Checked){ $params['ModAfter']=$dtAfter.Value.Date }
  if ($cbBefore.Checked){ $params['ModBefore']=$dtBefore.Value.Date }
  foreach($c in $form.Controls){ try { $c.Enabled=$false } catch{} }
  try {
    $res = New-FileMapCsv @params
    $global:__lastRoot = $tbRoot.Text.Trim()
    $global:__lastRows = @(Import-Csv -LiteralPath $res.Csv -Encoding UTF8)
    $btnOpen.Enabled=$true
    $btnDup.Enabled=($global:__lastRows | ? { $_.sha256 } | Measure-Object).Count -gt 0
    [System.Windows.Forms.MessageBox]::Show("CSV generado:`n$($res.Csv)`nFilas: $($res.Count)")
  } catch { [System.Windows.Forms.MessageBox]::Show($_.Exception.Message) }
  foreach($c in $form.Controls){ try { $c.Enabled=$true } catch{} }
})

$btnOpen.Add_Click({ if ($tbOut.Text) { Start-Process explorer.exe $tbOut.Text } })
$btnLoad.Add_Click({
  $f = Browse-OpenFile; if ($f) {
    try { $global:__lastRows = @(Import-Csv -LiteralPath $f -Encoding UTF8); $btnDup.Enabled=($global:__lastRows | ? { $_.sha256 } | Measure-Object).Count -gt 0 }
    catch { [System.Windows.Forms.MessageBox]::Show($_.Exception.Message) }
  }
})
$btnDup.Add_Click({
  try {
    if ($global:__lastRows.Count -eq 0) { [System.Windows.Forms.MessageBox]::Show("No hay datos cargados."); return }
    if (-not (Ensure-Under-Users $tbDest.Text)) { [System.Windows.Forms.MessageBox]::Show("Acciones limitadas a C:\Users\. Cambia el destino."); return }
    Action-Move-DuplicatesByHash -Rows $global:__lastRows -DestRoot $tbDest.Text.Trim() -KeepBy 'OldestMtime'
    [System.Windows.Forms.MessageBox]::Show("Duplicados movidos a:`n$($tbDest.Text)")
  } catch { [System.Windows.Forms.MessageBox]::Show($_.Exception.Message) }
})
$btnMoveF.Add_Click({
  try {
    if ($global:__lastRows.Count -eq 0) { [System.Windows.Forms.MessageBox]::Show("No hay datos cargados."); return }
    if (-not (Ensure-Under-Users $tbDest.Text)) { [System.Windows.Forms.MessageBox]::Show("Acciones limitadas a C:\Users\. Cambia el destino."); return }
    Action-Move-ByFilter -Rows $global:__lastRows -DestRoot $tbDest.Text.Trim() -IncludeExt $tbAFInc.Text -ExcludeExt $tbAFExc.Text -MinSizeMB $numAFMin.Value -MaxSizeMB $numAFMax.Value -OlderThanDays $numAFAge.Value
    [System.Windows.Forms.MessageBox]::Show("Mover por filtro completado.")
  } catch { [System.Windows.Forms.MessageBox]::Show($_.Exception.Message) }
})

# Extractor
$btnRunX.Add_Click({
  try {
    $target = if ($tbXT.Text) { $tbXT.Text } else { $tbRoot.Text }
    if (-not (Test-Path -LiteralPath $target)) { [System.Windows.Forms.MessageBox]::Show("Define Objetivo del extractor."); return }
    $res = Run-Extractor -Target $target -Recurse:$cbRec.Checked -AsciiMin $numAM.Value -CP936Min $numCM.Value -DryRun:$cbDry.Checked
    [System.Windows.Forms.MessageBox]::Show("Extractor completado.`nCSV: $($res.Csv)")
  } catch { [System.Windows.Forms.MessageBox]::Show($_.Exception.Message) }
})

[void]$form.ShowDialog()
return
'@

# Escribir como UTF-8 SIN BOM
$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
[System.IO.File]::WriteAllText($dst, $code, $utf8NoBom)

# Desbloquear por si Windows lo marca como descargado
try { Unblock-File -LiteralPath $dst } catch {}

Write-Host "✔ Archivo creado en: $dst"
Write-Host "Para ejecutar:  pwsh -ExecutionPolicy Bypass -File `"$dst`""
```