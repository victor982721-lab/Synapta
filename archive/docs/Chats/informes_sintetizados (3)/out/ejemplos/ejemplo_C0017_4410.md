```powershell
# YSD300AN_csv_only.ps1
# Extrae cadenas "de interfaz" (ASCII/UTF-16LE) altamente filtradas a un CSV depurable.

$ErrorActionPreference = 'Stop'

# == Entradas (ajusta si cambian rutas) ==
$src = @(
  'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\YSD_300AN\YSD300AN.exe',
  'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\300AN\YSD300AN-P2406.exe'
)

# == Salida ==
$outDir = 'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software\_strings'
New-Item -ItemType Directory -Force -Path $outDir | Out-Null

function Get-AsciiRuns {
  param([byte[]]$Bytes,[int]$Min=3)
  $buf=@(); $start=0; $i=0
  while($i -lt $Bytes.Length){
    $b=$Bytes[$i]
    $is = ($b -ge 0x20 -and $b -le 0x7E) -or $b -in 0x09,0x0A,0x0D
    if($is){ if($buf.Count -eq 0){ $start=$i }; $buf+=$b }
    else{ if($buf.Count -ge $Min){ 
            [pscustomobject]@{ Offset=$start; Encoding='ascii'; Text=[System.Text.Encoding]::ASCII.GetString($buf) }
          }; $buf=@() }
    $i++
  }
  if($buf.Count -ge $Min){ [pscustomobject]@{ Offset=$start; Encoding='ascii'; Text=[System.Text.Encoding]::ASCII.GetString($buf) } }
}

function Get-Utf16LeRuns {
  param([byte[]]$Bytes,[int]$Min=3)
  $len=$Bytes.Length
  $i=0; $start=-1; $chars=@()
  while($i + 1 -lt $len){
    $wc = [BitConverter]::ToUInt16($Bytes,$i)
    $is = ($wc -ge 0x20 -and $wc -ne 0x7F) -or $wc -in 0x0009,0x000A,0x000D
    if($is){
      if($start -lt 0){ $start=$i }
      $chars += [char]$wc
      $i += 2
    } else {
      if($start -ge 0 -and $chars.Count -ge $Min){
        [pscustomobject]@{ Offset=$start; Encoding='utf16le'; Text=([string]::new($chars)) }
      }
      $start=-1; $chars=@(); $i += 2
    }
  }
  if($start -ge 0 -and $chars.Count -ge $Min){
    [pscustomobject]@{ Offset=$start; Encoding='utf16le'; Text=([string]::new($chars)) }
  }
}

function Score-Text {
  param([string]$s)
  $t = $s.Trim()
  if($t.Length -lt 3 -or $t.Length -gt 160){ return 0.0 }

  # descartar blobs con muchos caracteres no “UI”
  $letters = ($t -replace "[^A-Za-zÁÉÍÓÚÜÑáéíóúüñ0-9 \t\-\.,:;!?'\"()_/\\\[\]{}%&@#\+°ºª=<>|]", "").Length
  $ratio = $letters / [double]$t.Length

  # penalizaciones
  $pen = 0.0
  if($t -match '^[\p{IsCJKUnifiedIdeographs}\p{IsHangul}\p{IsHiragana}\p{IsKatakana}]+$'){ $pen += 0.5 } # si todo CJK, lo dejamos pero con penal
  if($t -match '^\p{P}+$'){ return 0.0 }
  if($t -match '^[0-9\-\.:/ ]+$'){ return 0.0 }
  if($t -match '(.)\1\1\1'){ $pen += 0.3 }        # mismo char repetido
  if($t -match '[^\x20-\x7E]'){ $pen += 0.1 }     # caracteres fuera ASCII visibles

  $base = $ratio                             # 0..1
  if($t -match '(File|Edit|Help|OK|Cancel|Aceptar|Cancelar|Puerto|Baud|Error|Com|Guardar|Abrir|Conectar|Desconectar)'){ $base += 0.25 }
  [math]::Max(0.0,[math]::Min(1.0,$base - $pen))
}

function Clean-Text {
  param([string]$s)
  ($s -replace '[\r\n]+',' ' -replace '\s{2,}',' ').Trim()
}

foreach($file in $src){
  if(-not (Test-Path $file)){ Write-Warning "No existe: $file"; continue }
  $bytes = [IO.File]::ReadAllBytes($file)

  $raw = @()
  $raw += Get-AsciiRuns  -Bytes $bytes -Min 3
  $raw += Get-Utf16LeRuns -Bytes $bytes -Min 3

  $cands = $raw | ForEach-Object {
    $txt = Clean-Text $_.Text
    $score = Score-Text $txt
    [pscustomobject]@{
      Archivo   = [IO.Path]::GetFileName($file)
      OffsetHex = ('0x{0:X}' -f $_.Offset)
      Encoding  = $_.Encoding
      Longitud  = $txt.Length
      Confianza = '{0:N2}' -f $score
      Texto     = $txt
    }
  } | Where-Object { [double]$_.Confianza -ge 0.60 } |
      Sort-Object -Property @{e='Confianza';Descending=$true}, Longitud

  # dedup por Texto+Archivo
  $seen = @{}
  $final = foreach($r in $cands){
    $k = $r.Archivo + '|' + $r.Texto
    if(-not $seen.ContainsKey($k)){ $seen[$k]=$true; $r }
  }

  $base = [IO.Path]::GetFileNameWithoutExtension($file)
  $csv  = Join-Path $outDir ($base + '_ui_strings.csv')
  $final | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csv
  Write-Host "[OK] $base -> $csv"
}

Write-Host ""
Write-Host "Salida en: $outDir"
```