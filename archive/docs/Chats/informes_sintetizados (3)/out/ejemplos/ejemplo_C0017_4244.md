```powershell
#Requires -Version 7.0
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

param(
  # Carpeta donde están los .md
  [string]$Root = 'C:\Users\VictorFabianVeraVill\Desktop\TBEA\01_Software',
  # Archivos .md a procesar (exactos)
  [string[]]$Files = @('YSD300AN.md','YSD300AN-P2406.md'),
  # Carpeta de salida
  [string]$OutDir = (Join-Path $Root 'i18n_work'),
  # Nombre del CSV depurable
  [string]$OutCsv = 'strings_candidates.csv'
)

# ---------- Encodings ----------
[System.Text.Encoding]::RegisterProvider([System.Text.CodePagesEncodingProvider]::Instance) | Out-Null
$encGB18030 = [System.Text.Encoding]::GetEncoding('GB18030')     # chino (binario en .md)
$encLatin1  = [System.Text.Encoding]::GetEncoding('ISO-8859-1')  # “ASCII extendido” rápido

# ---------- Reglas / Filtros ----------
$UiWhitelist = @(
  'OK','Cancel','Apply','Close','Help','Open','Save','Yes','No','Retry','Abort','Ignore',
  'Next','Back','Finish','Browse','Start','Stop','Connect','Disconnect','Port','COM',
  'Baud','Baud Rate','Bits','Parity','Stop Bits','Data Bits','Language','Chinese','English',
  'Device','Status','Error','Warning','Information','Settings','Options','Default','Reset',
  'Print','Export','Import','About','Version','File','Edit','View','Tools','Window'
)

$reCJK         = '\p{IsCJKUnifiedIdeographs}'
$reAsciiChunk  = '[\p{IsBasicLatin}\t \-\_\.\,\:\;\(\)\[\]\{\}\/\\\+\=\!\?%°\|]+'      # trozos ASCII legibles
$reTitleUI     = '^(?:[A-Z][a-z]+(?: [A-Z][a-z]+){0,4})$'                              # “About Window”, etc.
$rePathLike    = '(?:[A-Za-z]:\\|\\\\|/|\.exe\b|\.dll\b|\.sys\b)'                      # rutas/archivos
$reGuid        = '\b[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}\b'
$reFence       = '^[\`\-_=]{3,}$'                                                      # ``` --- ==== etc.

function New-Row {
  param($file,$encoding,$offset,[string]$text,$class)
  $norm = ($text -replace '\s+',' ' ).Trim(' .')
  if (-not $norm) { return $null }

  # ratio de dígitos y de puntuación para filtrar ruido
  $len = $norm.Length
  $digits = ($norm.ToCharArray() | Where-Object { $_ -match '\d' }).Count
  $punct  = ($norm.ToCharArray() | Where-Object { $_ -notmatch '[\p{L}\p{N}\s]' }).Count
  if (($digits / [double]$len) -gt 0.5) { return $null }
  if (($punct  / [double]$len) -gt 0.5) { return $null }

  # id estable por texto
  $mem = [System.IO.MemoryStream]::new([byte[]][char[]]$norm)
  $id  = (Get-FileHash -InputStream $mem -Algorithm SHA256).Hash.Substring(0,16)

  [pscustomobject]@{
    Id         = $id
    Text       = $norm
    Class      = $class
    Encoding   = $encoding
    File       = $file
    Offset     = $offset
    Length     = $len
  }
}

function Extract-AsciiStrings {
  param([byte[]]$Bytes,[string]$File)
  $s = $encLatin1.GetString($Bytes)
  $matches = [regex]::Matches($s, $reAsciiChunk)
  foreach ($m in $matches) {
    $t = $m.Value.Trim()
    if ($t.Length -lt 2 -or $t.Length -gt 60) { continue }
    if ($t -match $reFence -or $t -match $rePathLike -or $t -match $reGuid) { continue }
    if ($t -notmatch '[A-Za-z]') { continue }                          # requiere letra
    $looksTitle = $t -match $reTitleUI
    $hasSpace   = $t -match '\S\s+\S'
    $inWhite    = $UiWhitelist -contains $t
    if ($looksTitle -or $hasSpace -or $inWhite) {
      New-Row -file $File -encoding 'ASCII' -offset $m.Index -text $t -class 'ui_en'
    }
  }
}

function Extract-WideAscii {
  param([byte[]]$Bytes,[string]$File)
  $out = New-Object System.Collections.Generic.List[object]
  $i = 0
  while ($i -lt ($Bytes.Length - 3)) {
    if ($Bytes[$i] -ge 32 -and $Bytes[$i] -le 126 -and $Bytes[$i+1] -eq 0) {
      $start = $i
      $chars = New-Object System.Collections.Generic.List[string]
      while ($i -lt ($Bytes.Length - 1) -and $Bytes[$i+1] -eq 0 -and $Bytes[$i] -ge 9 -and $Bytes[$i] -le 126) {
        $chars.Add([char]$Bytes[$i]); $i += 2
      }
      $t = (-join $chars).Trim()
      if ($t.Length -ge 2 -and $t.Length -le 60 -and $t -notmatch $rePathLike -and $t -notmatch $reGuid -and $t -match '[A-Za-z]') {
        $looksTitle = $t -match $reTitleUI
        $hasSpace   = $t -match '\S\s+\S'
        $inWhite    = $UiWhitelist -contains $t
        if ($looksTitle -or $hasSpace -or $inWhite) {
          $out.Add((New-Row -file $File -encoding 'UTF-16LE' -offset $start -text $t -class 'ui_en_wide'))
        }
      }
      continue
    }
    $i++
  }
  $out
}

function Extract-CJK {
  param([byte[]]$Bytes,[string]$File)
  $s = $encGB18030.GetString($Bytes)
  $rx = '(?=(?:.*' + $reCJK + '))' + '[\p{IsBasicLatin}\p{IsCJKUnifiedIdeographs}\p{IsPunctuation}\p{IsNumber}\s]{2,60}'
  $matches = [regex]::Matches($s, $rx)
  foreach ($m in $matches) {
    $t = ($m.Value -replace '\s+',' ').Trim(' .')
    if ($t.Length -lt 2) { continue }
    if ($t -match $reFence -or $t -match $rePathLike -or $t -match $reGuid) { continue }
    New-Row -file $File -encoding 'GB18030' -offset $m.Index -text $t -class 'zh'
  }
}

# ---------- MAIN ----------
if (-not (Test-Path -LiteralPath $OutDir)) { New-Item -ItemType Directory -Path $OutDir | Out-Null }

$targets = foreach($name in $Files) { Join-Path $Root $name } |
           Where-Object { Test-Path -LiteralPath $_ } |
           ForEach-Object { Get-Item -LiteralPath $_ }

if (-not $targets) { throw "No se encontraron los .md indicados en $Root." }

$rows = New-Object System.Collections.Generic.List[object]
foreach ($f in $targets) {
  Write-Host "[*] $($f.Name)" -ForegroundColor Cyan
  $bytes = [System.IO.File]::ReadAllBytes($f.FullName)
  $rows.AddRange((Extract-AsciiStrings -Bytes $bytes -File $f.Name))
  $rows.AddRange((Extract-WideAscii   -Bytes $bytes -File $f.Name))
  $rows.AddRange((Extract-CJK         -Bytes $bytes -File $f.Name))
}

# Deduplicar por texto, conservar primera aparición
$seen = @{}
$final = foreach($r in $rows){
  if (-not $seen.ContainsKey($r.Text)) { $seen[$r.Text] = 1; $r } else { $seen[$r.Text]++ }
} | ForEach-Object {
  $_ | Add-Member -NotePropertyName Occurrences -NotePropertyValue $seen[$_.Text] -PassThru
} | Sort-Object Class, Length, Text

$outPath = Join-Path $OutDir $OutCsv
$final | Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $outPath

Write-Host ""
Write-Host ("[OK] CSV depurable: {0}" -f $outPath) -ForegroundColor Green
Write-Host ("     Total candidatos: {0} (Únicos por texto)" -f $final.Count)
```