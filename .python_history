from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget, QStatusBar, QLineEdit, QLabel, QFileDialog
from PySide6.QtGui import QIcon
from PySide6.QtCore import Qt
from PIL import Image
import os
import subprocess
from datetime import datetime
# Función para registrar mensajes en el log
def Log_Message(message, messageType="INFO"):
        logFile = "application_log.txt"  # Asegúrate de definir la ruta correcta para el archivo de log
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                with open(logFile, 'a') as log:
                                log.write(f"{timestamp} - [{messageType}] - {message}\n")
                                
# Función para ejecutar comandos y registrar los resultados
def run_out(cmd, env=None):
            try:
                                result = subprocess.check_output(cmd, text=True, encoding="utf-8", errors="replace", env=env)
                                        Log_Message(f"Comando ejecutado correctamente: {cmd}", messageType="INFO")
                                                return result
                                                    except subprocess.CalledProcessError as e:
                                                                        errorMessage = f"Error ejecutando el comando: {cmd}\nSalida de error: {e.output}"
                                                                                Log_Message(errorMessage, messageType="ERROR")
                                                                                        raise RuntimeError(errorMessage)
                                                                                        
# Función para obtener el intérprete de Python
def Get_PythonInterpreter():
                try:
                                        result = subprocess.check_output(["py", "--version"], stderr=subprocess.STDOUT, text=True)
                                                Log_Message("Usando 'py' para gestionar Python.", messageType="INFO")
                                                        return "py"
                                                            except subprocess.CalledProcessError:
                                                                                    try:
                                                                                                                result = subprocess.check_output(["python", "--version"], stderr=subprocess.STDOUT, text=True)
                                                                                                                            Log_Message("Usando 'python' como intérprete.", messageType="INFO")
                                                                                                                                        return "python"
                                                                                                                                                except subprocess.CalledProcessError:
                                                                                                                                                                            Log_Message("No se encontró Python en el sistema.", messageType="ERROR")
                                                                                                                                                                                        raise RuntimeError("No se pudo encontrar Python 3.8-3.12 en este sistema.")
                                                                                                                                                                                        
# Función para convertir imágenes a ICO o PNG
def convert_image(image_path, output_dir, convert_ico=True, convert_png=True):
                    img = Image.open(image_path)
                        
    # Convertir a ICO de 256px
    if convert_ico:
        ico_path = os.path.join(output_dir, "output_icon.ico")
        img = img.resize((256, 256))
        img.save(ico_path, format='ICO')
        Log_Message(f"Imagen convertida a ICO: {ico_path}", messageType="INFO")
    
    # Convertir a PNG de 512px
    if convert_png:
        png_path = os.path.join(output_dir, "output_image.png")
        img = img.resize((512, 512))
        img.save(png_path, format='PNG')
        Log_Message(f"Imagen convertida a PNG: {png_path}", messageType="INFO")
    
    return ico_path, png_path
# Función para seleccionar el archivo de imagen
def select_image_file():
                        options = QFileDialog.Options()
                            options |= QFileDialog.ReadOnly
                                file, _ = QFileDialog.getOpenFileName(None, "Seleccionar Imagen", "", "Archivos de Imagen (*.png *.jpg *.jpeg)", options=options)
                                    return file
                                    
# Función para manejar instalación de dependencias con manejo específico de errores
def pip_install(py_exe, pkgs, log=None):
                            try:
                                                                run_out([str(py_exe), "-m", "pip", "install", "--upgrade", "pip", "setuptools", "wheel"], log=log)
                                                                        if pkgs:
                                                                                                                run_out([str(py_exe), "-m", "pip", "install", *pkgs], log=log)
                                                                                                                    except Exception as e:
                                                                                                                                                        errorMessage = f"Error en la instalación de dependencias: {str(e)}"
                                                                                                                                                                Log_Message(errorMessage, messageType="ERROR")
                                                                                                                                                                        raise RuntimeError(errorMessage)
                                                                                                                                                                        
# Configuración de la aplicación y diseño de la GUI con estilo oscuro
app = QApplication([])
# Establecer estilo oscuro global
app.setStyleSheet("""
QWidget {
    background-color: #2e2e2e;
            color: #e0e0e0;
                }
                
QPushButton {
    background-color: #444444;
            color: #ffffff;
                    border-radius: 5px;
                        padding: 10px;
                        }
                        
QPushButton:hover {
    background-color: #666666;
        }
        
QLineEdit, QPlainTextEdit {
    background-color: #333333;
            color: #ffffff;
                    border: 1px solid #444444;
                        padding: 5px;
                        }
                        
QLabel {
    color: #ffffff;
        }
        
QStatusBar {
    background-color: #1a1a1a;
            color: #ffffff;
                }
                """)
# Crear la ventana principal
window = QMainWindow()
window.setWindowTitle("Compilador de Scripts (Qt)")
# Botón para seleccionar imagen y convertirla
select_image_button = QPushButton("Seleccionar imagen")
select_image_button.clicked.connect(lambda: select_image_file())
# Botón para convertir la imagen seleccionada
convert_button = QPushButton("Convertir Imagen")
convert_button.clicked.connect(lambda: convert_image("path_to_selected_image", "path_to_output_directory"))
# Crear el layout
layout = QVBoxLayout()
layout.addWidget(select_image_button)
layout.addWidget(convert_button)
# Crear un widget central
widget = QWidget()
widget.setLayout(layout)
# Establecer el widget central
window.setCentralWidget(widget)
# Crear y configurar la barra de estado
status_bar = QStatusBar()
window.setStatusBar(status_bar)
status_bar.showMessage("Listo para comenzar", 5000)  # Mensaje por 5 segundos
# Mostrar la ventana
window.show()
# Ejecutar la aplicación
app.exec()
# El código Python que deseas guardar en el archivo
python_code = '''
from PySide6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QPushButton, QStatusBar, QFileDialog, QLabel
from PySide6.QtCore import Qt
from PySide6.QtGui import QIcon
from datetime import datetime
import os

# Función para registrar mensajes en el log
def Log_Message(message, messageType="INFO"):
        logFile = "application_log.txt"  # Asegúrate de definir la ruta correcta para el archivo de log
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                with open(logFile, 'a') as log:
                                log.write(f"{timestamp} - [{messageType}] - {message}\\n")
                                
# Función para generar el filemap
def generar_filemap(carpeta):
            salida = os.path.join(carpeta, "filemap.txt")
            
    with open(salida, "w", encoding="utf-8") as f:
                    f.write(f"# Filemap generado\\n# Carpeta: {carpeta}\\n\\n")
                            for root, dirs, files in os.walk(carpeta):
                                                rel_root = os.path.relpath(root, carpeta)
                                                            if rel_root == ".":
                                                                                    rel_root = ""
                                                                                                f.write(f"[DIR ] {rel_root}\\n")
                                                                                                            for file in files:
                                                                                                                                    rel_path = os.path.join(rel_root, file)
                                                                                                                                                    f.write(f"      {rel_path}\\n")
                                                                                                                                                    
    Log_Message(f"Filemap generado en {salida}", messageType="INFO")
        return salida
        
# Función para seleccionar una carpeta con QFileDialog
def select_folder():
            carpeta = QFileDialog.getExistingDirectory(None, "Selecciona una carpeta")
                if carpeta:
                                generar_filemap(carpeta)
                                
# Configuración de la aplicación y diseño de la GUI con estilo oscuro
app = QApplication([])

# Establecer estilo oscuro global
app.setStyleSheet("""
QWidget {
    background-color: #2e2e2e;
                color: #e0e0e0;
                        }
                        
QPushButton {
    background-color: #444444;
                color: #ffffff;
                            border-radius: 5px;
                                padding: 10px;
                                }
                                
QPushButton:hover {
    background-color: #666666;
            }
            
QLineEdit, QPlainTextEdit {
    background-color: #333333;
                color: #ffffff;
                            border: 1px solid #444444;
                                padding: 5px;
                                }
                                
QLabel {
    color: #ffffff;
            }
            
QStatusBar {
    background-color: #1a1a1a;
                color: #ffffff;
                        }
                        """)
                        
# Crear la ventana principal
window = QMainWindow()
window.setWindowTitle("Compilador de Scripts (Qt)")

# Crear un botón para seleccionar una carpeta y generar el filemap
btn_select_folder = QPushButton("Seleccionar carpeta y generar Filemap")
btn_select_folder.clicked.connect(lambda: select_folder())

# Crear el layout
layout = QVBoxLayout()
layout.addWidget(btn_select_folder)

# Crear un widget central
widget = QWidget()
widget.setLayout(layout)

# Establecer el widget central
window.setCentralWidget(widget)

# Crear y configurar la barra de estado
status_bar = QStatusBar()
window.setStatusBar(status_bar)
status_bar.showMessage("Listo para comenzar", 5000)  # Mensaje por 5 segundos

# Mostrar la ventana
window.show()

# Ejecutar la aplicación
app.exec()
'''
# Ruta donde guardar el archivo Python
desktop_path = "C:/Users/VictorFabianVeraVill/Desktop"
file_path = os.path.join(desktop_path, "filemap_gui.py")
# Escribir el código Python en el archivo
with open(file_path, "w") as file:
            file.write(python_code)
            
print(f"El archivo Python se ha guardado en: {file_path}")
ip install PySide6
ip install PySide6
exit()
import os
import pyflakes.api
import autopep8
def detectar_errores_sintaxis(codigo):
        """Detecta errores de sintaxis en el código Python utilizando pyflakes"""
            errores = []
                archivo_temporal = "temp.py"
                
    with open(archivo_temporal, "w") as f:
        f.write(codigo)
    # Usamos pyflakes para detectar errores en el archivo temporal
    with open(archivo_temporal, "r") as f:
        errores = pyflakes.api.checkPath(archivo_temporal)
    # Eliminamos el archivo temporal
    os.remove(archivo_temporal)
    return errores
def corregir_indentacion(codigo):
            """Corrige la indentación del código utilizando autopep8"""
                return autopep8.fix_code(codigo)
                
def procesar_md(input_file, output_file):
                """Procesa el archivo markdown, detectando errores de sintaxis y corrigiendo la indentación."""
                    with open(input_file, "r") as md_file:
                                            lines = md_file.readlines()
                                            
    nuevo_contenido = []
    en_bloque_codigo = False
    bloque_codigo = ""
    for linea in lines:
        # Verificar si es el inicio de un bloque de código
        if linea.startswith("```python"):
            en_bloque_codigo = True
            bloque_codigo = ""
            nuevo_contenido.append(linea)
        elif linea.startswith("```") and en_bloque_codigo:
            # Al finalizar un bloque de código
            if bloque_codigo:
                # Comprobar si hay errores de sintaxis
                errores = detectar_errores_sintaxis(bloque_codigo)
                if errores:
                    nuevo_contenido.append("# Error en el bloque de código. Se omite debido a errores de sintaxis.\n")
                else:
                    # Corregir la indentación del bloque de código
                    bloque_codigo_corregido = corregir_indentacion(bloque_codigo)
                    nuevo_contenido.append(bloque_codigo_corregido)
            nuevo_contenido.append(linea)
            en_bloque_codigo = False
        elif en_bloque_codigo:
            # Acumular el código en el bloque
            bloque_codigo += linea
        else:
            # Copiar línea tal cual si no está en un bloque de código
            nuevo_contenido.append(linea)
    # Escribir el nuevo archivo Markdown
    with open(output_file, "w") as output:
        output.writelines(nuevo_contenido)
if __name__ == "__main__":
                    input_file = "documento.md"  # Nombre del archivo Markdown de entrada
                        output_file = "documento_corregido.md"  # Nombre del archivo Markdown de salida
                            procesar_md(input_file, output_file)
                                print(f"El archivo correg
                                
pip install pyflakes autopep8
pip install pyflakes autopep8
exit()
# download_restore_tooling.py
import os, sys, re, json, time, pathlib, urllib.request
OUTDIR = pathlib.Path.cwd() / f"SM-A546E_restore_{time.strftime('%Y%m%d')}"
OUTDIR.mkdir(exist_ok=True)
def dl(url, dst):
        print(f"[+] {url} -> {dst}")
            with urllib.request.urlopen(url) as r, open(dst, "wb") as f:
                            f.write(r.read())
                            
def httpget(url, headers=None):
            req = urllib.request.Request(url, headers=headers or {"User-Agent":"Mozilla/5.0"})
                with urllib.request.urlopen(req) as r:
                                    return r.read()
                                    
# 1) Samsung USB Driver (oficial)
# Fuente: Samsung Developers (v1.9.0.0 - Apr 10, 2025)
# Si cambia el token, abre la página citada y toma el enlace más reciente.
DRIVER_URL = "https://developer.samsung.com/SDP/file/65386e3a-909e-4da5-86d2-7ded21d84b79"
try:
                dl(DRIVER_URL, OUTDIR / "Samsung_Android_USB_Driver.exe")
                except Exception as e:
                                    print(f"[!] Driver directo falló: {e}\n    Abre la página oficial y descarga manualmente.")
                                    
# 2) Frija (última release en GitHub)
try:
                    api = "https://api.github.com/repos/SlackingVeteran/frija/releases/latest"
                        rel = json.loads(httpget(api))
                            assets = [a for a in rel.get("assets", []) if a["browser_download_url"].lower().endswith((".zip",".exe"))]
                                if not assets:
                                                            raise RuntimeError("No assets in latest release")
                                                                # prefiero .zip si existe
                                                                    assets.sort(key=lambda a: (0 if a["browser_download_url"].lower().endswith(".zip") else 1))
                                                                        frija_url = assets[0]["browser_download_url"]
                                                                            dst_name = pathlib.Path(urllib.request.urlparse(frija_url).path).name or "Frija_latest.zip"
                                                                                dl(frija_url, OUTDIR / dst_name)
                                                                                except Exception as e:
                                                                                                        print(f"[!] Frija (API) falló: {e}\n    Abre la página de releases de Frija y descarga manualmente.")
                                                                                                        
# 3) Odin (intento de extracción de link .zip desde odindownload)
try:
                        page = httpget("https://odindownload.com/Odin-Download.html").decode("utf-8","ignore")
                            # buscar .zip con Odin3
                                m = re.search(r'href=["\'](https?://[^"\']*Odin[^"\']*\.zip)["\']', page, re.I)
                                    if m:
                                                                    odin_url = m.group(1)
                                                                            dst_name = pathlib.Path(urllib.request.urlparse(odin_url).path).name or "Odin.zip"
                                                                                    dl(odin_url, OUTDIR / dst_name)
                                                                                        else:
                                                                                                                        # guarda el HTML para que lo abras y descargues a mano
                                                                                                                                                        (OUTDIR / "Odin_page.html").write_text(page, encoding="utf-8")
                                                                                                                                                                print("[!] No se encontró un .zip directo para Odin. Se guardó Odin_page.html para descarga manual.")
                                                                                                                                                                except Exception as e:
                                                                                                                                                                                            print(f"[!] Odin (scrape) falló: {e}\n    Abre la página y descarga el ZIP manualmente.")
print(f"\nListo. Carpeta de salida: {OUTDIR}")
exit()
